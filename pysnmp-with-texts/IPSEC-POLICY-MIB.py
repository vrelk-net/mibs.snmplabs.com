#
# PySNMP MIB module IPSEC-POLICY-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/selby1jr/src/mibs/mibs.snmplabs.com/asn1/IPSEC-POLICY-MIB
# Produced by pysmi-0.3.4 at Wed Jul 24 12:11:47 2024
# On host IT-156955 platform Linux version 5.15.153.1-microsoft-standard-WSL2 by user selby1jr
# Using Python version 3.10.12 (main, Mar 22 2024, 16:50:05) [GCC 11.4.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
InetPortNumber, InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetPortNumber", "InetAddressType", "InetAddress")
IkeHashAlgorithm, IkeAuthMethod, IpsecDoiIdentType, IpsecDoiAuthAlgorithm, IpsecDoiEncapsulationMode, IkeEncryptionAlgorithm, IpsecDoiIpcompTransform, IpsecDoiSecProtocolId, IpsecDoiEspTransform, IkeGroupDescription = mibBuilder.importSymbols("IPSEC-ISAKMP-IKE-DOI-TC", "IkeHashAlgorithm", "IkeAuthMethod", "IpsecDoiIdentType", "IpsecDoiAuthAlgorithm", "IpsecDoiEncapsulationMode", "IkeEncryptionAlgorithm", "IpsecDoiIpcompTransform", "IpsecDoiSecProtocolId", "IpsecDoiEspTransform", "IkeGroupDescription")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Bits, MibIdentifier, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, iso, Gauge32, TimeTicks, Unsigned32, ModuleIdentity, mib_2, Counter32, Counter64, Integer32, NotificationType, experimental = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "MibIdentifier", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "iso", "Gauge32", "TimeTicks", "Unsigned32", "ModuleIdentity", "mib-2", "Counter32", "Counter64", "Integer32", "NotificationType", "experimental")
VariablePointer, StorageType, TruthValue, RowStatus, TimeStamp, TextualConvention, DisplayString, DateAndTime = mibBuilder.importSymbols("SNMPv2-TC", "VariablePointer", "StorageType", "TruthValue", "RowStatus", "TimeStamp", "TextualConvention", "DisplayString", "DateAndTime")
ipspMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 153))
ipspMIB.setRevisions(('2003-01-07 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ipspMIB.setRevisionsDescriptions(('Initial version, published as RFC xxxx.',))
if mibBuilder.loadTexts: ipspMIB.setLastUpdated('200212100000Z')
if mibBuilder.loadTexts: ipspMIB.setOrganization('IETF IP Security Policy Working Group')
if mibBuilder.loadTexts: ipspMIB.setContactInfo('Michael Baer Network Associates, Inc. 3965 Freedom Circle, Suite 500 Santa Clara, CA 95054 Phone: +1 530 902 3131 Email: mike_baer@nai.com Ricky Charlet Email: rcharlet@alumni.calpoly.edu Wes Hardaker Network Associates, Inc. 3965 Freedom Circle, Suite 500 Santa Clara, CA 95054 Phone: +1 530 400 2774 Email: wes_hardaker@nai.com Robert Story Revelstone Software PO Box 1474 Duluth, GA 30096 Phone: +1 770 617 3722 Email: ipsp-mib@revelstone.com Cliff Wang SmartPipes Inc. Suite 300, 565 Metro Place South Dublin, OH 43017 Phone: +1 614 923 6241 E-Mail: CWang@smartpipes.com')
if mibBuilder.loadTexts: ipspMIB.setDescription('The MIB module for defining IPsec Policy filters and actions. Copyright (C) The Internet Society (2003). This version of this MIB module is part of RFC XXXX, see the RFC itself for full legal notices.')
ipspConfigObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 153, 1))
ipspNotificationObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 153, 2))
ipspConformanceObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 153, 3))
class IpspBooleanOperator(TextualConvention, Integer32):
    description = 'The IpspBooleanOperator operator is used to specify whether sub-components in a decision making process are ANDed or ORed together to decide if the resulting expression is true or false.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("or", 1), ("and", 2))

class IpspAdminStatus(TextualConvention, Integer32):
    description = 'The IpspAdminStatus is used to specify the administrative status of an object. Objects which are disabled must not be used by the packet processing engine.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("enabled", 1), ("disabled", 2))

class IpspSADirection(TextualConvention, Integer32):
    description = 'The IpspSADirection operator is used to specify whether or not a row should apply to outgoing or incoming SAs.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("outgoing", 1), ("incoming", 2))

class IpspIPPacketLogging(TextualConvention, Integer32):
    description = "IpspIPPacketLogging specifies whether or not an audit message should be logged when a packet is passed through an SA. A value of '-1' indicates no logging. A value of '0' or greater indicates that logging should be done and how many bytes of the beginning of the packet to place in the log. Values greater than the size of the packet being processed indicate that the entire packet should be sent. Examples: '-1' no logging '0' log but do not include any of the packet in the log '20' log and include the first 20 bytes of the packet in the log."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(-1, 65536)

class IpspIdentityFilter(TextualConvention, OctetString):
    description = 'IpspIdentityFilter contains a string encoded Identity Type value to be used in comparisons against an IKE Identity payload. Wherever this TC is used, there should be an accompanying column which uses the IpsecDoiIdentType TC to specify the type of data in this object. See the IpsecDoiIdentType TC for the supported identity types available. Note that the IpsecDoiIdentType TC sepcifies how to encode binary values, while this object will contain human readable string versions.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 256)

class IpspCredentialType(TextualConvention, Integer32):
    description = 'IpspCredentialType identifies the type of credential contained in a corresponding IpspIdentityFilter object.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))
    namedValues = NamedValues(("reserved", 0), ("unknown", 1), ("sharedSecret", 2), ("x509", 3), ("kerberos", 4))

ipspLocalConfigObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 153, 1, 1))
ipspSystemPolicyGroupName = MibScalar((1, 3, 6, 1, 2, 1, 153, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipspSystemPolicyGroupName.setStatus('current')
if mibBuilder.loadTexts: ipspSystemPolicyGroupName.setDescription("This object indicates the policy group containing the global system policy that is to be applied when a given endpoint does not contain a policy definition. Its value can be used as an index into the ipspGroupContentsTable to retrieve a list of policies. A zero length string indicates no system wide policy exists and the default policy of 'accept' should be executed until one is imposed by either this object or by the endpoint processing a given packet.")
ipspEndpointToGroupTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 2), )
if mibBuilder.loadTexts: ipspEndpointToGroupTable.setStatus('current')
if mibBuilder.loadTexts: ipspEndpointToGroupTable.setDescription('This table is used to map policy (groupings) onto an endpoint where traffic is to pass by. Any policy group assigned to an endpoint is then used to control access to the traffic passing by it. If an endpoint has been configured with a policy group and no contained rule matches the incoming packet, the default action in this case shall be to drop the packet. If no policy group has been assigned to an endpoint, then the policy group specified by ipspSystemPolicyGroupName should be used for the endpoint.')
ipspEndpointToGroupEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 2, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspEndGroupIdentType"), (0, "IPSEC-POLICY-MIB", "ipspEndGroupAddress"))
if mibBuilder.loadTexts: ipspEndpointToGroupEntry.setStatus('current')
if mibBuilder.loadTexts: ipspEndpointToGroupEntry.setDescription('A mapping assigning a policy group to an endpoint.')
ipspEndGroupIdentType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 2, 1, 1), InetAddressType())
if mibBuilder.loadTexts: ipspEndGroupIdentType.setStatus('current')
if mibBuilder.loadTexts: ipspEndGroupIdentType.setDescription('The Internet Protocol version of the address associated with a given endpoint. All addresses are represented as an array of octets in network byte order. When combined with the ipspEndGroupAddress these objects can be used to uniquely identify an endpoint that a set of policy groups should be applied to. Devices supporting IPv4 MUST support the ipv4 value, and devices supporting IPv6 MUST support the ipv6 value. Values of unknown, ipv4z, ipv6z and dns are not legal values for this object.')
ipspEndGroupAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 2, 1, 2), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: ipspEndGroupAddress.setStatus('current')
if mibBuilder.loadTexts: ipspEndGroupAddress.setDescription('The address of a given endpoint, the format of which is specified by the ipspEndGroupIdentType object.')
ipspEndGroupName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 2, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspEndGroupName.setStatus('current')
if mibBuilder.loadTexts: ipspEndGroupName.setDescription('The policy group name to apply to this endpoint. The value of the ipspEndGroupName object should then be used as an index into the ipspGroupContentsTable to come up with a list of rules that MUST be applied to this endpoint.')
ipspEndGroupLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 2, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspEndGroupLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspEndGroupLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspEndGroupStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 2, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspEndGroupStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspEndGroupStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspEndGroupRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspEndGroupRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspEndGroupRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. This object may not be set to active until one or more active rows exist within the ipspGroupContentsTable for the group referenced by the ipspEndGroupName object.')
ipspGroupContentsTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 3), )
if mibBuilder.loadTexts: ipspGroupContentsTable.setStatus('current')
if mibBuilder.loadTexts: ipspGroupContentsTable.setDescription('This table contains a list of rules and/or subgroups contained within a given policy group. The entries are sorted by the ipspGroupContPriority object and MUST be executed in order according to this value, starting with the lowest value. Once a group item has been processed, the processor MUST stop processing this packet if an action was executed as a result of the processing of a given group. Iterating into the next policy group item by finding the next largest ipspGroupContPriority object shall only be done if no actions were run when processing the last item for a given packet.')
ipspGroupContentsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 3, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspGroupContName"), (0, "IPSEC-POLICY-MIB", "ipspGroupContPriority"))
if mibBuilder.loadTexts: ipspGroupContentsEntry.setStatus('current')
if mibBuilder.loadTexts: ipspGroupContentsEntry.setDescription('Defines a given sub-item within a policy group.')
ipspGroupContName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 3, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspGroupContName.setStatus('current')
if mibBuilder.loadTexts: ipspGroupContName.setDescription('The administrative name of this group.')
ipspGroupContPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536)))
if mibBuilder.loadTexts: ipspGroupContPriority.setStatus('current')
if mibBuilder.loadTexts: ipspGroupContPriority.setDescription('The priority (sequence number) of the sub-component in this group.')
ipspGroupContFilter = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 3, 1, 3), VariablePointer().clone((1, 3, 6, 1, 2, 1, 153, 1, 7, 1, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspGroupContFilter.setStatus('current')
if mibBuilder.loadTexts: ipspGroupContFilter.setDescription('ipspGroupContFilter points to a filter which is evaluated to determine whether the sub-component within this group should be exercised. Managers can use this object to classify groups of rules or subgroups together in order to achieve a greater degree of control and optimization over the execution order of the items within the group. If the filter evaluates to false, the rule or subgroup will be skipped and the next rule or subgroup will be evaluated instead. An example usage of this object would be to limit a group of rules to executing only when the IP packet being process is designated to be processed by IKE. This effecitevly creates a group of IKE specific rules. This MIB defines the following tables and scalars which may be pointed to by this column. Implementations may choose to provide support for other filter tables or scalars as well: ipspIpHeaderFilterTable ipspIpOffsetFilterTable ipspTimeFilterTable ipspCompoundFilterTable ipspTrueFilter If this column is set to a VariablePointer value which references a non-existent row in an otherwise supported table, the inconsistentName exception should be returned. If the table or scalar pointed to by the VariablePointer is not supported at all, then an inconsistentValue exception should be returned.')
ipspGroupContComponentType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("reserved", 0), ("group", 1), ("rule", 2))).clone('rule')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspGroupContComponentType.setStatus('current')
if mibBuilder.loadTexts: ipspGroupContComponentType.setDescription('Indicates whether the ipspGroupContComponentName object is the name of another group defined within the ipspGroupContentsTable or is the name of a rule defined within the ipspRuleDefinitionTable.')
ipspGroupContComponentName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 3, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspGroupContComponentName.setStatus('current')
if mibBuilder.loadTexts: ipspGroupContComponentName.setDescription('The name of the policy rule or subgroup contained within this group, as indicated by the ipspGroupContComponentType object.')
ipspGroupContLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 3, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspGroupContLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspGroupContLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspGroupContStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 3, 1, 7), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspGroupContStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspGroupContStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspGroupContRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 3, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspGroupContRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspGroupContRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. This object may not be set to active until the row to which the ipspGroupContComponentName points to exists.')
ipspRuleDefinitionTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 4), )
if mibBuilder.loadTexts: ipspRuleDefinitionTable.setStatus('current')
if mibBuilder.loadTexts: ipspRuleDefinitionTable.setDescription('This table defines a policy rule by associating a filter or a set of filters to an action to be executed.')
ipspRuleDefinitionEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 4, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspRuleDefName"))
if mibBuilder.loadTexts: ipspRuleDefinitionEntry.setStatus('current')
if mibBuilder.loadTexts: ipspRuleDefinitionEntry.setDescription('A row defining a particular policy definition. A rule definition binds a filter pointer to an action pointer.')
ipspRuleDefName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 4, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspRuleDefName.setStatus('current')
if mibBuilder.loadTexts: ipspRuleDefName.setDescription('ipspRuleDefName is the administratively assigned name of the rule referred to by the ipspGroupContComponentName object.')
ipspRuleDefDescription = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 4, 1, 2), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspRuleDefDescription.setStatus('current')
if mibBuilder.loadTexts: ipspRuleDefDescription.setDescription('A user definable string. This field may be used for your administrative tracking purposes.')
ipspRuleDefFilter = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 4, 1, 3), VariablePointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspRuleDefFilter.setStatus('current')
if mibBuilder.loadTexts: ipspRuleDefFilter.setDescription('ipspRuleDefFilter points to a filter which is used to evaluate whether the action associated with this row should be fired or not. The action will only fire if the filter referenced by this object evaluates to TRUE after first applying any negation required by the ipspRuleDefFilterNegated object. This MIB defines the following tables and scalars which may be pointed to by this column. Implementations may choose to provide support for other filter tables or scalars as well: ipspIpHeaderFilterTable ipspIpOffsetFilterTable ipspTimeFilterTable ipspCompoundFilterTable ipspTrueFilter If this column is set to a VariablePointer value which references a non-existent row in an otherwise supported table, the inconsistentName exception should be returned. If the table or scalar pointed to by the VariablePointer is not supported at all, then an inconsistentValue exception should be returned.')
ipspRuleDefFilterNegated = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 4, 1, 4), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspRuleDefFilterNegated.setStatus('current')
if mibBuilder.loadTexts: ipspRuleDefFilterNegated.setDescription('ipspRuleDefFilterNegated specifies whether the filter referenced by the ipspRuleDefFilter object should be negated or not.')
ipspRuleDefAction = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 4, 1, 5), VariablePointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspRuleDefAction.setStatus('current')
if mibBuilder.loadTexts: ipspRuleDefAction.setDescription('This column points to the action to be taken. It may, but is not limited to, point to a row in one of the following tables: ipspCompoundActionTable ipspSaPreconfiguredActionTable ipspIkeActionTable ipspIpsecActionTable It may also point to one of the scalar objects beneath ipspStaticActions. If this object is set to a pointer to a row in an unsupported (or unknown) table, an inconsistentValue error should be returned. If this object is set to point to a non-existent row in an otherwise supported table, an inconsistentName error should be returned.')
ipspRuleDefAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 4, 1, 6), IpspAdminStatus().clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspRuleDefAdminStatus.setStatus('current')
if mibBuilder.loadTexts: ipspRuleDefAdminStatus.setDescription("Indicates whether the current rule definition should be considered active. If enabled, it should be evaluated when processing packets. If disabled, packets should continue to be processed by the rest of the rules defined in the ipspGroupContentsTable as if this rule's filters had effectively failed.")
ipspRuleDefLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 4, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspRuleDefLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspRuleDefLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspRuleDefStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 4, 1, 8), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspRuleDefStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspRuleDefStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspRuleDefRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 4, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspRuleDefRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspRuleDefRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. This object may not be set to active until the containing contitions, filters and actions have been defined. Once active, it must remain active until no policyGroupContents entries are referencing it.')
ipspCompoundFilterTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 5), )
if mibBuilder.loadTexts: ipspCompoundFilterTable.setStatus('current')
if mibBuilder.loadTexts: ipspCompoundFilterTable.setDescription('A table defining a compound set of filters and their associated parameters. A row in this table can either be pointed to by a ipspRuleDefFilter object or by a ficSubFilter object.')
ipspCompoundFilterEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 5, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspCompFiltName"))
if mibBuilder.loadTexts: ipspCompoundFilterEntry.setStatus('current')
if mibBuilder.loadTexts: ipspCompoundFilterEntry.setDescription('An entry in the ipspCompoundFilterTable. A filter defined by this table is considered to have a TRUE return value if and only if: ipspCompFiltLogicType is AND and all of the sub-filters associated with it, as defined in the ipspSubfiltersTable, are all true themselves (after applying any requried negation as defined by the ficFilterIsNegated object). ipspCompFiltLogicType is OR and at least one of the sub-filters associated with it, as defined in the ipspSubfiltersTable, is true itself (after applying any requried negation as defined by the ficFilterIsNegated object).')
ipspCompFiltName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 5, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspCompFiltName.setStatus('current')
if mibBuilder.loadTexts: ipspCompFiltName.setDescription('A user definable string. You may use this field for your administrative tracking purposes.')
ipspCompFiltDescription = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 5, 1, 2), SnmpAdminString().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCompFiltDescription.setStatus('current')
if mibBuilder.loadTexts: ipspCompFiltDescription.setDescription('A user definable string. You may use this field for your administrative tracking purposes.')
ipspCompFiltLogicType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 5, 1, 3), IpspBooleanOperator().clone('and')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCompFiltLogicType.setStatus('current')
if mibBuilder.loadTexts: ipspCompFiltLogicType.setDescription('Indicates whether the filters contained within this filter are functionally ANDed or ORed together.')
ipspCompFiltLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 5, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspCompFiltLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspCompFiltLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspCompFiltStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 5, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCompFiltStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspCompFiltStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspCompFiltRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 5, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCompFiltRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspCompFiltRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. Once active, it may not have its value changed if any active rows in the ipspRuleDefinitionTable are currently pointing at this row.')
ipspSubfiltersTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 6), )
if mibBuilder.loadTexts: ipspSubfiltersTable.setStatus('current')
if mibBuilder.loadTexts: ipspSubfiltersTable.setDescription('This table defines a list of filters contained within a given compound filter set defined in the ipspCompoundFilterTable.')
ipspSubfiltersEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 6, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspCompFiltName"), (0, "IPSEC-POLICY-MIB", "ipspSubFiltPriority"))
if mibBuilder.loadTexts: ipspSubfiltersEntry.setStatus('current')
if mibBuilder.loadTexts: ipspSubfiltersEntry.setDescription('An entry into the list of filters for a given compound filter.')
ipspSubFiltPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536)))
if mibBuilder.loadTexts: ipspSubFiltPriority.setStatus('current')
if mibBuilder.loadTexts: ipspSubFiltPriority.setDescription('The priority of a given filter within a condition. Implementations MAY choose to follow the ordering indicated by the manager that created the rows in order to allow the manager to intelligently construct filter lists such that faster filters are evaluated first.')
ipspSubFiltSubfilter = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 6, 1, 2), VariablePointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSubFiltSubfilter.setStatus('current')
if mibBuilder.loadTexts: ipspSubFiltSubfilter.setDescription('The location of the contained filter. The value of this column should be a VariablePointer which references the properties for the filter to be included in this compound filter. This MIB defines the following tables and scalars which may be pointed to by this column. Implementations may choose to provide support for other filter tables or scalars as well: ipspIpHeaderFilterTable ipspIpOffsetFilterTable ipspTimeFilterTable ipspCompoundFilterTable ipspTrueFilter If this column is set to a VariablePointer value which references a non-existent row in an otherwise supported table, the inconsistentName exception should be returned. If the table or scalar pointed to by the VariablePointer is not supported at all, then an inconsistentValue exception should be returned.')
ipspSubFiltSubfilterIsNegated = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 6, 1, 3), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSubFiltSubfilterIsNegated.setStatus('current')
if mibBuilder.loadTexts: ipspSubFiltSubfilterIsNegated.setDescription('Indicates whether the result of applying this subfilter should be negated or not.')
ipspSubFiltLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 6, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspSubFiltLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspSubFiltLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspSubFiltStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 6, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSubFiltStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspSubFiltStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspSubFiltRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 6, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSubFiltRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspSubFiltRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. This object can not be made active until the filter referenced by the ficSubFilter object is both defined and is active. An attempt to do so will result in an inconsistentValue error.')
ipspStaticFilters = MibIdentifier((1, 3, 6, 1, 2, 1, 153, 1, 7))
ipspTrueFilter = MibScalar((1, 3, 6, 1, 2, 1, 153, 1, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspTrueFilter.setStatus('current')
if mibBuilder.loadTexts: ipspTrueFilter.setDescription('This scalar indicates a (automatic) true result for a filter. I.e. this is a filter that is always true, useful for adding as a default filter for a default action or a set of actions.')
ipspTrueFilterInstance = MibIdentifier((1, 3, 6, 1, 2, 1, 153, 1, 7, 1, 0))
ipspIkePhase1Filter = MibScalar((1, 3, 6, 1, 2, 1, 153, 1, 7, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspIkePhase1Filter.setStatus('current')
if mibBuilder.loadTexts: ipspIkePhase1Filter.setDescription('This static filter can be used to test if a packet is part of an IKE phase-1 negotiation.')
ipspIkePhase2Filter = MibScalar((1, 3, 6, 1, 2, 1, 153, 1, 7, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspIkePhase2Filter.setStatus('current')
if mibBuilder.loadTexts: ipspIkePhase2Filter.setDescription('This static filter can be used to test if a packet is part of an IKE phase-2 negotiation.')
ipspIpHeaderFilterTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 8), )
if mibBuilder.loadTexts: ipspIpHeaderFilterTable.setStatus('current')
if mibBuilder.loadTexts: ipspIpHeaderFilterTable.setDescription('This table contains a list of filter definitions to be used within the ipspRuleDefinitionTable or the ipspSubfilterTable table.')
ipspIpHeaderFilterEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 8, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspIpHeadFiltName"))
if mibBuilder.loadTexts: ipspIpHeaderFilterEntry.setStatus('current')
if mibBuilder.loadTexts: ipspIpHeaderFilterEntry.setDescription('A definition of a particular filter.')
ipspIpHeadFiltName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 8, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspIpHeadFiltName.setStatus('current')
if mibBuilder.loadTexts: ipspIpHeadFiltName.setDescription('The administrative name for this filter.')
ipspIpHeadFiltType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 8, 1, 2), Bits().clone(namedValues=NamedValues(("sourceAddress", 0), ("destinationAddress", 1), ("sourcePort", 2), ("destinationPort", 3), ("protocol", 4), ("ipv6FlowLabel", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpHeadFiltType.setStatus('current')
if mibBuilder.loadTexts: ipspIpHeadFiltType.setDescription("This defines the various tests that are used when evaluating a given filter. The results of each test are ANDed together to produce the result of the entire filter. When processing this filter, it is recommended for efficiency reasons that the filter halt processing the instant any of the specified tests fail. Once a row is 'active', this object's value may not be changed unless all the appropriate columns needed by the new value to be imposed on this object have been appropriately configured. The various tests definable in this table are as follows: sourceAddress: - Tests if the source address in the packet lies between the ipspIpHeadFiltSrcAddressBegin and ipspIpHeadFiltSrcAddressEnd objects. Note that setting these two objects to the same address will limit the search to the exact match of a single address. The format and length of the address objects are defined by the ipspIpHeadFiltIPVersion column. A row in this table containing a ipspIpHeadFiltType object with the sourceAddress object bit but without the ipspIpHeadFiltIPVersion, ipspIpHeadFiltSrcAddressBegin and ipspIpHeadFiltSrcAddressEnd objects set will cause the ipspIpHeadFiltRowStatus object to return the notReady state. destinationAddress: - Tests if the destination address in the packet lies between the ipspIpHeadFiltDstAddressBegin and ipspIpHeadFiltDstAddressEnd objects. Note that setting these two objects to the same address will limit the search to the exact match of a single address. The format and length of the address objects are defined by the ipspIpHeadFiltIPVersion column. A row in this table containing a ipspIpHeadFiltType object with the destinationAddress object bit but without the ipspIpHeadFiltIPVersion, ipspIpHeadFiltDstAddressBegin and ipspIpHeadFiltDstAddressEnd objects set will cause the ipspIpHeadFiltRowStatus object to return the notReady state. sourcePort: - Tests if the source port of IP packets using a protocol that uses port numbers (at this time, UDP or TCP) lies between the ipspIpHeadFiltSrcLowPort and ipspIpHeadFiltSrcHighPort objects. Note that setting these two objects to the same address will limit the search to the exact match of a single port. A row in this table containing a ipspIpHeadFiltType object with the sourcePort object bit but without the ipspIpHeadFiltSrcLowPort, and ipspIpHeadFiltSrcHighPort objects set will cause the ipspIpHeadFiltRowStatus object to return the notReady state. destinationPort: - Tests if the source port of IP packets using a protocol that uses port numbers (at this time, UDP or TCP) lies between the ipspIpHeadFiltDstLowPort and ipspIpHeadFiltDstHighPort objects. Note that setting these two objects to the same address will limit the search to the exact match of a single port. A row in this table containing a ipspIpHeadFiltType object with the sourcePort object bit but without the ipspIpHeadFiltDstLowPort, and ipspIpHeadFiltDstHighPort objects set will cause the ipspIpHeadFiltRowStatus object to return the notReady state. protocol: - Tests to see if the packet being processed is for the given protocol type. A row in this table containing a ipspIpHeadFiltType object with the protocol object bit but without the ipspIpHeadFiltProtocol object set will cause the ipspIpHeadFiltRowStatus object to return the notReady state. ipv6FlowLabel: - Tests to see if the packet being processed contains an ipv6 Flow Label which matches the value in the ipfIPv6FlowLabel object. Setting this bit mandates that for the packet to match the filter, it must be an IPv6 packet. A row in this table containing a ipspIpHeadFiltType object with the ipv6FlowLabel object bit but without the ipfIPv6FlowLabel object set will cause the ipspIpHeadFiltRowStatus object to return the notReady state.")
ipspIpHeadFiltIPVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 8, 1, 3), InetAddressType().clone('ipv6')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpHeadFiltIPVersion.setStatus('current')
if mibBuilder.loadTexts: ipspIpHeadFiltIPVersion.setDescription('The Internet Protocol version the addresses are to match against. The value of this property determines the size and format of the ipspIpHeadFiltSrcAddressBegin, ipspIpHeadFiltSrcAddressEnd, ipspIpHeadFiltDstAddressBegin, and ipspIpHeadFiltDstAddressEnd objects. Values of unknown, ipv4z, ipv6z and dns are not legal values for this object.')
ipspIpHeadFiltSrcAddressBegin = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 8, 1, 4), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpHeadFiltSrcAddressBegin.setStatus('current')
if mibBuilder.loadTexts: ipspIpHeadFiltSrcAddressBegin.setDescription('The starting address of a source address range that the packet must match against for this filter to be considered TRUE. This object is only used if sourceAddress is set in ipspIpHeadFiltType.')
ipspIpHeadFiltSrcAddressEnd = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 8, 1, 5), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpHeadFiltSrcAddressEnd.setStatus('current')
if mibBuilder.loadTexts: ipspIpHeadFiltSrcAddressEnd.setDescription('The ending address of a source address range to check a packet against, where the starting is specified by the ipspIpHeadFiltSrcAddressBegin object. Set this column to the same value as the ipspIpHeadFiltSrcAddressBegin column to get an exact single address match. This object is only used if sourceAddress is set in ipspIpHeadFiltType.')
ipspIpHeadFiltDstAddressBegin = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 8, 1, 6), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpHeadFiltDstAddressBegin.setStatus('current')
if mibBuilder.loadTexts: ipspIpHeadFiltDstAddressBegin.setDescription('The starting address of a destination address range that the packet must match against for this filter to be considered TRUE. This object is only used if destinationAddress is set in ipspIpHeadFiltType.')
ipspIpHeadFiltDstAddressEnd = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 8, 1, 7), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpHeadFiltDstAddressEnd.setStatus('current')
if mibBuilder.loadTexts: ipspIpHeadFiltDstAddressEnd.setDescription('The ending address of a destination address range to check a packet against, where the first is specified by the ipspIpHeadFiltDstAddressBegin object. Set this column to the same value as the ipspIpHeadFiltDstAddressBegin column to get an exact single address match. This object is only used if destinationAddress is set in ipspIpHeadFiltType.')
ipspIpHeadFiltSrcLowPort = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 8, 1, 8), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpHeadFiltSrcLowPort.setStatus('current')
if mibBuilder.loadTexts: ipspIpHeadFiltSrcLowPort.setDescription("The low port of the port range a packet's source must match against. To match, the port number must be greater than or equal to this value. This object is only used if sourcePort is set in ipspIpHeadFiltType. The value of 0 for this object is illegal.")
ipspIpHeadFiltSrcHighPort = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 8, 1, 9), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpHeadFiltSrcHighPort.setStatus('current')
if mibBuilder.loadTexts: ipspIpHeadFiltSrcHighPort.setDescription("The high port of the port range a packet's source must match against. To match, the port number must be less than or equal to this value. This object is only used if sourcePort is set in ipspIpHeadFiltType. The value of 0 for this object is illegal.")
ipspIpHeadFiltDstLowPort = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 8, 1, 10), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpHeadFiltDstLowPort.setStatus('current')
if mibBuilder.loadTexts: ipspIpHeadFiltDstLowPort.setDescription("The low port of the port range a packet's destination must match against. To match, the port number must be greater than or equal to this value. This object is only used if destinationPort is set in ipspIpHeadFiltType. The value of 0 for this object is illegal.")
ipspIpHeadFiltDstHighPort = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 8, 1, 11), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpHeadFiltDstHighPort.setStatus('current')
if mibBuilder.loadTexts: ipspIpHeadFiltDstHighPort.setDescription("The high port of the port range a packet's destination must match against. To match, the port number must be less than or equal to this value. This object is only used if destinationPort is set in ipspIpHeadFiltType. The value of 0 for this object is illegal.")
ipspIpHeadFiltProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 8, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpHeadFiltProtocol.setStatus('current')
if mibBuilder.loadTexts: ipspIpHeadFiltProtocol.setDescription('The protocol number the incoming packet must match against for this filter to be evaluated as true. This object is only used if protocol is set in ipspIpHeadFiltType.')
ipspIpHeadFiltIPv6FlowLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 8, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048575))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpHeadFiltIPv6FlowLabel.setStatus('current')
if mibBuilder.loadTexts: ipspIpHeadFiltIPv6FlowLabel.setDescription('The IPv6 Flow Label that the packet must match against. This object is only used if ipv6FlowLabel is set in ipspIpHeadFiltType.')
ipspIpHeadFiltLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 8, 1, 14), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspIpHeadFiltLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspIpHeadFiltLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspIpHeadFiltStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 8, 1, 15), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpHeadFiltStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspIpHeadFiltStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspIpHeadFiltRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 8, 1, 16), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpHeadFiltRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspIpHeadFiltRowStatus.setDescription('This object indicates the conceptual status of this row. This object may not be set to active if the requirements of the ipspIpHeadFiltType object are not met. In other words, if the associated value columns needed by a particular test have not been set, then attempting to change this row to an active state will result in an inconsistentValue error. See the ipspIpHeadFiltType object description for further details.')
ipspIpOffsetFilterTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 9), )
if mibBuilder.loadTexts: ipspIpOffsetFilterTable.setStatus('current')
if mibBuilder.loadTexts: ipspIpOffsetFilterTable.setDescription('This table contains a list of filter definitions to be used within the ipspRuleDefinitionTable or the ipspSubfilterTable.')
ipspIpOffsetFilterEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 9, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspIpOffFiltName"))
if mibBuilder.loadTexts: ipspIpOffsetFilterEntry.setStatus('current')
if mibBuilder.loadTexts: ipspIpOffsetFilterEntry.setDescription('A definition of a particular filter.')
ipspIpOffFiltName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 9, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspIpOffFiltName.setStatus('current')
if mibBuilder.loadTexts: ipspIpOffFiltName.setDescription('The administrative name for this filter.')
ipspIpOffFiltOffset = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpOffFiltOffset.setStatus('current')
if mibBuilder.loadTexts: ipspIpOffFiltOffset.setDescription("This is the byte offset from the front of the IP packet where the value or arithmetic comparison is done. A value of '0' indicates the first byte in the packet.")
ipspIpOffFiltType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("valueMatch", 1), ("valueNotMatch", 2), ("arithmeticEqual", 3), ("arithmeticNotEqual", 4), ("arithmeticLess", 5), ("arithmeticGreaterOrEqual", 6), ("arithmeticGreater", 7), ("arithmeticLessOrEqual", 8)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpOffFiltType.setStatus('current')
if mibBuilder.loadTexts: ipspIpOffFiltType.setDescription("This defines the various tests that are used when evaluating a given filter. Once a row is 'active', this object's value may not be changed unless the appropriate columns, ipspIpOffFiltNumber or ipspIpOffFiltValue, needed by the new value to be imposed on this object have been appropriately configured. The various tests definable in this table are as follows: valueMatch: - Tests if the OCTET STRING, 'ipspIpOffFiltValue', matches a value in the packet starting at the given offset in the packet and comparing the entire OCTET STRING of 'ipspIpOffFiltValue'. valueNotMatch: - Tests if the OCTET STRING, 'ipspIpOffFiltValue', does not match a value in the packet starting at the given offset in the packet and comparing to the entire OCTET STRING of 'ipspIpOffFiltValue'. arithmeticEqual: - Tests if the Integer32, 'ipspIpOffFiltNumber', is arithmetically equal ('=') to the 4 byte value starting at the given offset within the packet. The value in the packet is assumed to be in network byte order. arithmeticNotEqual: - Tests if the Integer32, 'ipspIpOffFiltNumber', is arithmetically not equal ('!=') to the 4 byte value starting at the given offset within the packet. The value in the packet is assumed to be in network byte order. arithmeticLess: - Tests if the Integer32, 'ipspIpOffFiltNumber', is arithmetically less than ('<') the 4 byte value starting at the given offset within the packet. The value in the packet is assumed to be in network byte order. arithmeticGreaterOrEqual: - Tests if the Integer32, 'ipspIpOffFiltNumber', is arithmetically greater than or equal to ('>=') the 4 byte value starting at the given offset within the packet. The value in the packet is assumed to be in network byte order. arithmeticGreater: - Tests if the Integer32, 'ipspIpOffFiltNumber', is arithmetically greater than ('>') the 4 byte value starting at the given offset within the packet. The value in the packet is assumed to be in network byte order. arithmeticLessOrEqual: - Tests if the Integer32, 'ipspIpOffFiltNumber', is arithmetically less than or equal to ('<=') the 4 byte value starting at the given offset within the packet. The value in the packet is assumed to be in network byte order.")
ipspIpOffFiltNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 9, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpOffFiltNumber.setStatus('current')
if mibBuilder.loadTexts: ipspIpOffFiltNumber.setDescription('ipspIpOffFiltNumber is used for arithmetic matching of a packets at ipspIpOffFiltOffset. This object is only used if one of the arithmetic types is chosen in ipspIpOffFiltType.')
ipspIpOffFiltValue = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 9, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpOffFiltValue.setStatus('current')
if mibBuilder.loadTexts: ipspIpOffFiltValue.setDescription('ipspIpOffFiltValue is used for match comparisons of a packet at ipspIpOffFiltOffset. This object is only used if one of the match types is chosen in ipspIpOffFiltType.')
ipspIpOffFiltLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 9, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspIpOffFiltLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspIpOffFiltLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspIpOffFiltStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 9, 1, 7), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpOffFiltStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspIpOffFiltStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspIpOffFiltRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 9, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpOffFiltRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspIpOffFiltRowStatus.setDescription('This object indicates the conceptual status of this row. This object may not be set to active if the requirements of the ipspIpOffFiltType object are not met. In other words, if the associated value columns needed by a particular test have not been set, then attempting to change this row to an active state will result in an inconsistentValue error. See the ipspIpOffFiltType object description for further details.')
ipspTimeFilterTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 10), )
if mibBuilder.loadTexts: ipspTimeFilterTable.setStatus('current')
if mibBuilder.loadTexts: ipspTimeFilterTable.setDescription('Defines a table of filters which can be used to effectively enable or disable policies based on a valid time range.')
ipspTimeFilterEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 10, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspTimeFiltName"))
if mibBuilder.loadTexts: ipspTimeFilterEntry.setStatus('current')
if mibBuilder.loadTexts: ipspTimeFilterEntry.setDescription('A row describing a given time frame for which a policy may be filtered on to place the rule active or inactive.')
ipspTimeFiltName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 10, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspTimeFiltName.setStatus('current')
if mibBuilder.loadTexts: ipspTimeFiltName.setDescription('An administratively assigned name for this filter.')
ipspTimeFiltPeriodStart = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 10, 1, 2), DateAndTime().clone(hexValue="00000101000000002b0000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspTimeFiltPeriodStart.setStatus('current')
if mibBuilder.loadTexts: ipspTimeFiltPeriodStart.setDescription('The starting time period for this filter. In addition to a normal DateAndTime string, this object may be set to the OCTET STRING value THISANDPRIOR which indicates that the filter is valid from any time before now up until (at least) now.')
ipspTimeFiltPeriodEnd = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 10, 1, 3), DateAndTime().clone(hexValue="99991231235959092b0000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspTimeFiltPeriodEnd.setStatus('current')
if mibBuilder.loadTexts: ipspTimeFiltPeriodEnd.setDescription('The ending time period for this filter. In addition to a normal DateAndTime string, this object may be set to the OCTET STRING value THISANDFUTURE which indicates that the filter is valid without an ending date and/or time.')
ipspTimeFiltMonthOfYearMask = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 10, 1, 4), Bits().clone(namedValues=NamedValues(("january", 0), ("february", 1), ("march", 2), ("april", 3), ("may", 4), ("june", 5), ("july", 6), ("august", 7), ("september", 8), ("october", 9), ("november", 10), ("december", 11))).clone(namedValues=NamedValues(("january", 0), ("february", 1), ("march", 2), ("april", 3), ("may", 4), ("june", 5), ("july", 6), ("august", 7), ("september", 8), ("october", 9), ("november", 10), ("december", 11)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspTimeFiltMonthOfYearMask.setStatus('current')
if mibBuilder.loadTexts: ipspTimeFiltMonthOfYearMask.setDescription('A bit mask which overlays the ipspTimeFiltPeriodStart to ipspTimeFiltPeriodEnd date range to further restrict the time period to a restricted set of months of the year.')
ipspTimeFiltDayOfMonthMask = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 10, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4).clone(hexValue="fffffffe")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspTimeFiltDayOfMonthMask.setStatus('current')
if mibBuilder.loadTexts: ipspTimeFiltDayOfMonthMask.setDescription('Defines which days of the month this time period is valid for. It is a sequence of 32 BITS, where each BIT represents a corresponding day of the month starting from the left most bit being equal to the first day of the month. The last bit in the string MUST be zero.')
ipspTimeFiltDayOfWeekMask = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 10, 1, 6), Bits().clone(namedValues=NamedValues(("monday", 0), ("tuesday", 1), ("wednesday", 2), ("thursday", 3), ("friday", 4), ("saturday", 5), ("sunday", 6))).clone(namedValues=NamedValues(("monday", 0), ("tuesday", 1), ("wednesday", 2), ("thursday", 3), ("friday", 4), ("saturday", 5), ("sunday", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspTimeFiltDayOfWeekMask.setStatus('current')
if mibBuilder.loadTexts: ipspTimeFiltDayOfWeekMask.setDescription('A bit mask which overlays the ipspTimeFiltPeriodStart to ipspTimeFiltPeriodEnd date range to further restrict the time period to a restricted set of days within a given week.')
ipspTimeFiltTimeOfDayMaskStart = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 10, 1, 7), DateAndTime().clone(hexValue="00000000000000002b0000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspTimeFiltTimeOfDayMaskStart.setStatus('current')
if mibBuilder.loadTexts: ipspTimeFiltTimeOfDayMaskStart.setDescription('Indicates the starting time of day for which this filter evaluates to true. The date portions of the DateAndTime TC are ignored for purposes of evaluating this mask and only the time specific portions are used.')
ipspTimeFiltTimeOfDayMaskEnd = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 10, 1, 8), DateAndTime().clone(hexValue="00000000000000002b0000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspTimeFiltTimeOfDayMaskEnd.setStatus('current')
if mibBuilder.loadTexts: ipspTimeFiltTimeOfDayMaskEnd.setDescription('Indicates the ending time of day for which this filter evaluates to true. The date portions of the DateAndTime TC are ignored for purposes of evaluating this mask and only the time specific portions are used. If this starting and ending time values indicated by the ipspTimeFiltTimeOfDayMaskStart and ipspTimeFiltTimeOfDayMaskEnd objects are equal, the filter is expected to be evaluated over the entire 24 hour period.')
ipspTimeFiltLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 10, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspTimeFiltLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspTimeFiltLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspTimeFiltStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 10, 1, 10), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspTimeFiltStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspTimeFiltStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspTimeFiltRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 10, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspTimeFiltRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspTimeFiltRowStatus.setDescription('This object indicates the conceptual status of this row.')
ipspIpsoHeaderFilterTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 11), )
if mibBuilder.loadTexts: ipspIpsoHeaderFilterTable.setStatus('current')
if mibBuilder.loadTexts: ipspIpsoHeaderFilterTable.setDescription('This table contains a list of IPSO header filter definitions to be used within the ipspRuleDefinitionTable or the ipspSubfilterTable. IPSO headers and their values are described in RFC1108.')
ipspIpsoHeaderFilterEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 11, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspIpsoHeadFiltName"))
if mibBuilder.loadTexts: ipspIpsoHeaderFilterEntry.setStatus('current')
if mibBuilder.loadTexts: ipspIpsoHeaderFilterEntry.setDescription('A definition of a particular filter.')
ipspIpsoHeadFiltName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 11, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspIpsoHeadFiltName.setStatus('current')
if mibBuilder.loadTexts: ipspIpsoHeadFiltName.setDescription('The administrative name for this filter.')
ipspIpsoHeadFiltType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 11, 1, 2), Bits().clone(namedValues=NamedValues(("classificationLevel", 0), ("protectionAuthority", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsoHeadFiltType.setStatus('current')
if mibBuilder.loadTexts: ipspIpsoHeadFiltType.setDescription('The IPSO header fields to match the value against.')
ipspIpsoHeadFiltClassification = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(61, 90, 150, 171))).clone(namedValues=NamedValues(("topSecret", 61), ("secret", 90), ("confidential", 150), ("unclassified", 171)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsoHeadFiltClassification.setStatus('current')
if mibBuilder.loadTexts: ipspIpsoHeadFiltClassification.setDescription('The IPSO classification header field value must match the value in this column if the classificationLevel bit is set in the ipspIpsoHeadFiltType field. The values of these enumerations are defined by RFC1108.')
ipspIpsoHeadFiltProtectionAuth = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("genser", 0), ("siopesi", 1), ("sci", 2), ("nsa", 3), ("doe", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsoHeadFiltProtectionAuth.setStatus('current')
if mibBuilder.loadTexts: ipspIpsoHeadFiltProtectionAuth.setDescription('The IPSO protection authority header field value must match the value in this column if the protection authority bit is set in the ipspIpsoHeadFiltType field. The values of these enumerations are defined by RFC1108. Hence the reason the SMIv2 convention of not using 0 in enum lists is violated here.')
ipspIpsoHeadFiltLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 11, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspIpsoHeadFiltLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspIpsoHeadFiltLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspIpsoHeadFiltStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 11, 1, 6), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsoHeadFiltStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspIpsoHeadFiltStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspIpsoHeadFiltRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 11, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsoHeadFiltRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspIpsoHeadFiltRowStatus.setDescription('This object indicates the conceptual status of this row. This object may not be set to active if the requirements of the ipspIpsoHeadFiltType object are not met. In other words, if the associated value columns needed by a particular test have not been set, then attempting to change this row to an active state will result in an inconsistentValue error. See the ipspIpsoHeadFiltType object description for further details.')
ipspCredentialFilterTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 12), )
if mibBuilder.loadTexts: ipspCredentialFilterTable.setStatus('current')
if mibBuilder.loadTexts: ipspCredentialFilterTable.setDescription('This table defines filters which can be used to match credentials of IKE peers, where the credentials in question have been obtained from an IKE phase 1 exchange. They may be X.509 certificates, Kerberos tickets, etc...')
ipspCredentialFilterEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 12, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspCredFiltName"))
if mibBuilder.loadTexts: ipspCredentialFilterEntry.setStatus('current')
if mibBuilder.loadTexts: ipspCredentialFilterEntry.setDescription('A row defining a particular credential filter')
ipspCredFiltName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 12, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspCredFiltName.setStatus('current')
if mibBuilder.loadTexts: ipspCredFiltName.setDescription('The administrative name of this filter.')
ipspCredFiltCredentialType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 12, 1, 2), IpspCredentialType().clone('x509')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCredFiltCredentialType.setStatus('current')
if mibBuilder.loadTexts: ipspCredFiltCredentialType.setDescription('The credential type that is expected for this filter to succeed.')
ipspCredFiltMatchFieldName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 12, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCredFiltMatchFieldName.setStatus('current')
if mibBuilder.loadTexts: ipspCredFiltMatchFieldName.setDescription('The piece of the credential to match against. Examples: serialNumber, signatureAlgorithm, issuerName or subjectName. For credential types without fields (e.g. shared secrec), this field should be left empty, and the entire credential will be matched against the ipspCredFiltMatchFieldValue.')
ipspCredFiltMatchFieldValue = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 12, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 4096))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCredFiltMatchFieldValue.setStatus('current')
if mibBuilder.loadTexts: ipspCredFiltMatchFieldValue.setDescription('The value that the field indicated by the ipspCredFiltMatchFieldName must match against for the filter to be considered TRUE.')
ipspCredFiltAcceptCredFrom = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 12, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 117))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCredFiltAcceptCredFrom.setStatus('current')
if mibBuilder.loadTexts: ipspCredFiltAcceptCredFrom.setDescription('This value is used to look up a row in the ipspIpsecCredMngServiceTable for the Certificate Authority (CA) Information. This value is empty if there is no CA used for this filter.')
ipspCredFiltLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 12, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspCredFiltLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspCredFiltLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspCredFiltStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 12, 1, 7), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCredFiltStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspCredFiltStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspCredFiltRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 12, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCredFiltRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspCredFiltRowStatus.setDescription('This object indicates the conceptual status of this row.')
ipspPeerIdentityFilterTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 13), )
if mibBuilder.loadTexts: ipspPeerIdentityFilterTable.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdentityFilterTable.setDescription('This table defines filters which can be used to match credentials of IKE peers, where the credentials in question have been obtained from an IKE phase 1 exchange. They may be X.509 certificates, Kerberos tickets, etc...')
ipspPeerIdentityFilterEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 13, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspPeerIdFiltName"))
if mibBuilder.loadTexts: ipspPeerIdentityFilterEntry.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdentityFilterEntry.setDescription('A row defining a particular credential filter')
ipspPeerIdFiltName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 13, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspPeerIdFiltName.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdFiltName.setDescription('The administrative name of this filter.')
ipspPeerIdFiltIdentityType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 13, 1, 2), IpsecDoiIdentType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspPeerIdFiltIdentityType.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdFiltIdentityType.setDescription('The type of identity field in the peer ID payload to match against.')
ipspPeerIdFiltIdentityValue = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 13, 1, 3), IpspIdentityFilter()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspPeerIdFiltIdentityValue.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdFiltIdentityValue.setDescription("The string representation of the value that the peer ID payload value must match against. Wildcard mechanisms MUST be supported such that: - a ipspPeerIdFiltIdentityValue of '*@example.com' will match a userFqdn ID payload of 'JDOE@EXAMPLE.COM' - a ipspPeerIdFiltIdentityValue of '*.example.com' will match a fqdn ID payload of 'WWW.EXAMPLE.COM' - a ipspPeerIdFiltIdentityValue of: 'cn=*,ou=engineering,o=company,c=us' will match a DER DN ID payload of 'cn=John Doe,ou=engineering,o=company,c=us' - a ipspPeerIdFiltIdentityValue of '192.0.2.0/24' will match an IPv4 address ID payload of 192.0.2.10 - a ipspPeerIdFiltIdentityValue of '192.0.2.*' will also match an IPv4 address ID payload of 192.0.2.10. The character '*' replaces 0 or multiple instances of any character.")
ipspPeerIdFiltLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 13, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspPeerIdFiltLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdFiltLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspPeerIdFiltStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 13, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspPeerIdFiltStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdFiltStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspPeerIdFiltRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 13, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspPeerIdFiltRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdFiltRowStatus.setDescription('This object indicates the conceptual status of this row. This object can not be considered active unless the ipspPeerIdFiltIdentityType and ipspPeerIdFiltIdentityValue column values are defined.')
ipspCompoundActionTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 14), )
if mibBuilder.loadTexts: ipspCompoundActionTable.setStatus('current')
if mibBuilder.loadTexts: ipspCompoundActionTable.setDescription('Table used to allow multiple actions to be associated with a rule. It uses the ipspSubactionsTable to do this.')
ipspCompoundActionEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 14, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspCompActName"))
if mibBuilder.loadTexts: ipspCompoundActionEntry.setStatus('current')
if mibBuilder.loadTexts: ipspCompoundActionEntry.setDescription('A row in the ipspCompoundActionTable.')
ipspCompActName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 14, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspCompActName.setStatus('current')
if mibBuilder.loadTexts: ipspCompActName.setDescription('This is an administratively assigned name of this compound action.')
ipspCompActExecutionStrategy = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("reserved", 0), ("doAll", 1), ("doUntilSuccess", 2), ("doUntilFailure", 3))).clone('doUntilSuccess')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCompActExecutionStrategy.setStatus('current')
if mibBuilder.loadTexts: ipspCompActExecutionStrategy.setDescription('This object indicates how the sub-actions are executed based on the success of the actions as they finish executing. doAll - run each sub-action regardless of the exit status of the previous action. This parent action is always considered to have acted successfully. doUntilSuccess - run each sub-action until one succeeds, at which point stop processing the sub-actions within this parent compound action. If one of the sub-actions did execute successfully, this parent action is also considered to have executed sucessfully. doUntilFailure - run each sub-action until one fails, at which point stop processing the sub-actions within this compound action. If any sub-action fails, the result of this parent action is considered to have failed.')
ipspCompActLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 14, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspCompActLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspCompActLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspCompActStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 14, 1, 4), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCompActStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspCompActStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspCompActRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 14, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCompActRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspCompActRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. Once a row in the ipspCompoundActionTable has been made active, this object may not be set to destroy without first destroying all the contained rows listed in the ipspSubactionsTable.')
ipspSubactionsTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 15), )
if mibBuilder.loadTexts: ipspSubactionsTable.setStatus('current')
if mibBuilder.loadTexts: ipspSubactionsTable.setDescription('This table contains a list of the sub-actions within a given compound action. Compound actions executing these actions MUST execute them in series based on the ipspSubActPriority value, with the lowest value executing first.')
ipspSubactionsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 15, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspCompActName"), (0, "IPSEC-POLICY-MIB", "ipspSubActPriority"))
if mibBuilder.loadTexts: ipspSubactionsEntry.setStatus('current')
if mibBuilder.loadTexts: ipspSubactionsEntry.setDescription('A row containing a reference to a given compound-action sub-action.')
ipspSubActPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536)))
if mibBuilder.loadTexts: ipspSubActPriority.setStatus('current')
if mibBuilder.loadTexts: ipspSubActPriority.setDescription('The priority of a given sub-action within a compound action. The order in which sub-actions should be executed are based on the value from this column, with the lowest numeric value executing first.')
ipspSubActSubActionName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 15, 1, 2), VariablePointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSubActSubActionName.setStatus('current')
if mibBuilder.loadTexts: ipspSubActSubActionName.setDescription('This column points to the action to be taken. It may, but is not limited to, point to a row in one of the following tables: ipspCompoundActionTable - Allowing recursion ipspSaPreconfiguredActionTable ipspIkeActionTable ipspIpsecActionTable It may also point to one of the scalar objects beneath ipspStaticActions. If this object is set to a pointer to a row in an unsupported (or unknown) table, an inconsistentValue error should be returned. If this object is set to point to a non-existent row in an otherwise supported table, an inconsistentName error should be returned.')
aiipspCompActLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 15, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiipspCompActLastChanged.setStatus('current')
if mibBuilder.loadTexts: aiipspCompActLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
aiipspCompActStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 15, 1, 4), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aiipspCompActStorageType.setStatus('current')
if mibBuilder.loadTexts: aiipspCompActStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
aiipspCompActRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 15, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aiipspCompActRowStatus.setStatus('current')
if mibBuilder.loadTexts: aiipspCompActRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified.')
ipspStaticActions = MibIdentifier((1, 3, 6, 1, 2, 1, 153, 1, 16))
ipspDropAction = MibScalar((1, 3, 6, 1, 2, 1, 153, 1, 16, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspDropAction.setStatus('current')
if mibBuilder.loadTexts: ipspDropAction.setDescription('This scalar indicates that a packet should be dropped WITHOUT action/packet logging. This object returns a value of 1 for IPsec policy implementations that support the drop static action.')
ipspDropActionLog = MibScalar((1, 3, 6, 1, 2, 1, 153, 1, 16, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspDropActionLog.setStatus('current')
if mibBuilder.loadTexts: ipspDropActionLog.setDescription('This scalar indicates that a packet should be dropped WITH action/packet logging. This object returns a value of 1 for IPsec policy implementations that support the drop static action with logging.')
ipspAcceptAction = MibScalar((1, 3, 6, 1, 2, 1, 153, 1, 16, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspAcceptAction.setStatus('current')
if mibBuilder.loadTexts: ipspAcceptAction.setDescription('This Scalar indicates that a packet should be accepted (pass-through) WITHOUT action/packet logging. This object returns a value of 1 for IPsec policy implementations that support the accept static action.')
ipspAcceptActionLog = MibScalar((1, 3, 6, 1, 2, 1, 153, 1, 16, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspAcceptActionLog.setStatus('current')
if mibBuilder.loadTexts: ipspAcceptActionLog.setDescription('This scalar indicates that a packet should be accepted (pass-through) WITH action/packet logging. This object returns a value of 1 for IPsec policy implementations that support the accept static action with logging.')
ipspRejectIKEAction = MibScalar((1, 3, 6, 1, 2, 1, 153, 1, 16, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspRejectIKEAction.setStatus('current')
if mibBuilder.loadTexts: ipspRejectIKEAction.setDescription('This scalar indicates that a packet should be rejected WITHOUT action/packet logging. This object returns a value of 1 for IPsec policy implementations that support the reject static action.')
ipspRejectIKEActionLog = MibScalar((1, 3, 6, 1, 2, 1, 153, 1, 16, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspRejectIKEActionLog.setStatus('current')
if mibBuilder.loadTexts: ipspRejectIKEActionLog.setDescription('This scalar indicates that a packet should be rejected WITH action/packet logging. This object returns a value of 1 for IPsec policy implementations that support the reject static action with logging.')
ipspSaPreconfiguredActionTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 17), )
if mibBuilder.loadTexts: ipspSaPreconfiguredActionTable.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreconfiguredActionTable.setDescription('This table is a list of non-negotiated IPsec actions (SAs) that can be performed and contains or indicates the data necessary to create such an SA.')
ipspSaPreconfiguredActionEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 17, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspSaPreActActionName"), (0, "IPSEC-POLICY-MIB", "ipspSaPreActSADirection"))
if mibBuilder.loadTexts: ipspSaPreconfiguredActionEntry.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreconfiguredActionEntry.setDescription('One entry in the ipspSaPreconfiguredActionTable.')
ipspSaPreActActionName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspSaPreActActionName.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActActionName.setDescription('This object contains the name of this SaPreconfiguredActionEntry.')
ipspSaPreActSADirection = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 2), IpspSADirection())
if mibBuilder.loadTexts: ipspSaPreActSADirection.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActSADirection.setDescription('This object indicates whether a row should apply to outgoing or incoming SAs')
ipspSaPreActActionDescription = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 3), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaPreActActionDescription.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActActionDescription.setDescription('An administratively assigned string which may be used to describe what the action does.')
ipspSaPreActActionLifetimeSec = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 4), Unsigned32().clone(28800)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaPreActActionLifetimeSec.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActActionLifetimeSec.setDescription('ipspSaPreActActionLifetimeSec specifies how long in seconds the security association derived from this action should be used. The default lifetime is 8 hours. Note: the actual lifetime of the preconfigured SA will be the lesser of the value of this object and of the value of the MaxLifetimeSecs property of the associated transform. A value of 0 indicates no time limit on the lifetime of the SA.')
ipspSaPreActActionLifetimeKB = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaPreActActionLifetimeKB.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActActionLifetimeKB.setDescription("ipspSaPreActActionLifetimeKB specifies how long the security association derived from this action should be used. After this value in KiloBytes has passed through the security association, it should no longer be used. Note: the actual lifetime of the preconfigured SA will be the lesser of the value of this object and of the value of the MaxLifetimeKB property of the associated transform. The default value, '0', indicates no kilobyte limit.")
ipspSaPreActDoActionLogging = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaPreActDoActionLogging.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActDoActionLogging.setDescription('ipspSaPreActDoActionLogging specifies whether or not an audit message should be logged when a preconfigured SA is created.')
ipspSaPreActDoPacketLogging = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 7), IpspIPPacketLogging().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaPreActDoPacketLogging.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActDoPacketLogging.setDescription('ipspSaPreActDoPacketLogging specifies whether or not an audit message should be logged and if there is logging, how many bytes of the packet to place in the notification.')
ipspSaPreActDFHandling = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("reserved", 0), ("copy", 1), ("set", 2), ("clear", 3))).clone('copy')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaPreActDFHandling.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActDFHandling.setDescription('This object specifies how to process the DF bit in packets sent through the preconfigured SA. This object is not used for transport SAs.')
ipspSaPreActActionType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 9), IpsecDoiEncapsulationMode().clone('tunnel')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaPreActActionType.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActActionType.setDescription('This object specifies the encapsulation mode to use for the preconfigured SA: tunnel or transport mode.')
ipspSaPreActAHSPI = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaPreActAHSPI.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActAHSPI.setDescription('This object represents the SPI value for the AH SA.')
ipspSaPreActAHTransformName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 11), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaPreActAHTransformName.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActAHTransformName.setDescription('This object is the name of the AH transform to use as an index into the AHTransformTable. A zero length value indicates no transform of this type is used.')
ipspSaPreActAHSharedSecretName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 12), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaPreActAHSharedSecretName.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActAHSharedSecretName.setDescription('This object contains a name value to be used as an index into the ipspCredentialTable which holds the pertinent keying information for the AH SA.')
ipspSaPreActESPSPI = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 13), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaPreActESPSPI.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActESPSPI.setDescription('This object represents the SPI value for the ESP SA.')
ipspSaPreActESPTransformName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 14), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaPreActESPTransformName.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActESPTransformName.setDescription('This object is the name of the ESP transform to use as an index into the ESPTransformTable. A zero length value indicates no transform of this type is used.')
ipspSaPreActESPEncSecretName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 15), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaPreActESPEncSecretName.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActESPEncSecretName.setDescription('This object contains a name value to be used as an index into the ipspCredentialTable which holds the pertinent keying information for the encryption algorithm of the ESP SA.')
ipspSaPreActESPAuthSecretName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 16), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaPreActESPAuthSecretName.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActESPAuthSecretName.setDescription('This object contains a name value to be used as an index into the ipspCredentialTable which holds the pertinent keying information for the authentication algorithm of the ESP SA.')
ipspSaPreActIPCompSPI = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 17), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaPreActIPCompSPI.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActIPCompSPI.setDescription('This object represents the SPI value for the IPComp SA.')
ipspSaPreActIPCompTransformName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 18), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaPreActIPCompTransformName.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActIPCompTransformName.setDescription('This object is the name of the IPComp transform to use as an index into the IPCompTransformTable. A zero length value indicates no transform of this type is used.')
ipspSaPreActPeerGatewayIdName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 19), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaPreActPeerGatewayIdName.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActPeerGatewayIdName.setDescription('This object indicates the peer id name of the peer gateway. This object can be used to look up the peer gateway address in the ipspPeerIdentityTable. This object is only used when initiating a tunnel SA, and is not used for transport SAs. If ipspSaPreActActionType specifies tunnel mode and this object is empty, the peer gateway should be determined from the source or destination of the packet.')
ipspSaPreActLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 20), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspSaPreActLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspSaPreActStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 21), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaPreActStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspSaPreActRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 17, 1, 22), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaPreActRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspSaPreActRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object must remain active if it is referenced by a row in another table.')
ipspSaNegotiationParametersTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 18), )
if mibBuilder.loadTexts: ipspSaNegotiationParametersTable.setStatus('current')
if mibBuilder.loadTexts: ipspSaNegotiationParametersTable.setDescription('This table contains reusable parameters that can be pointed to by the ipspIkeActionTable and ipspIpsecActionTable. These parameters are reusable since it is likely an administrator will want to make global policy changes to lifetime parameters that apply to multiple actions. This table allows multiple rows in the other actions tables to reuse global lifetime parameters in this table by repeatedly pointing to a row cointained within this table.')
ipspSaNegotiationParametersEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 18, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspSaNegParamName"))
if mibBuilder.loadTexts: ipspSaNegotiationParametersEntry.setStatus('current')
if mibBuilder.loadTexts: ipspSaNegotiationParametersEntry.setDescription('Contains the attributes of one row in the ipspSaNegotiationParametersTable.')
ipspSaNegParamName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 18, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspSaNegParamName.setStatus('current')
if mibBuilder.loadTexts: ipspSaNegParamName.setDescription('This object contains the administrative name of this SaNegotiationParametersEntry. This row can be referred to by this name in other policy action tables.')
ipspSaNegParamMinLifetimeSecs = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 18, 1, 2), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaNegParamMinLifetimeSecs.setStatus('current')
if mibBuilder.loadTexts: ipspSaNegParamMinLifetimeSecs.setDescription('ipspSaNegParamMinLifetimeSecs specifies the minimum seconds lifetime that will be accepted from the peer.')
ipspSaNegParamMinLifetimeKB = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 18, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaNegParamMinLifetimeKB.setStatus('current')
if mibBuilder.loadTexts: ipspSaNegParamMinLifetimeKB.setDescription('ipspSaNegParamMinLifetimeKB specifies the minimum kilobyte lifetime that will be accepted from the peer.')
ipspSaNegParamRefreshThreshSecs = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaNegParamRefreshThreshSecs.setStatus('current')
if mibBuilder.loadTexts: ipspSaNegParamRefreshThreshSecs.setDescription('ipspSaNegParamRefreshThreshSecs specifies what percentage of the seconds lifetime can expire before IKE should attempt to renegotiate the IPsec security association. A value between 1 and 100 representing a percentage. A value of 100 indicates that the IPsec security association should not be renegotiated until the seconds lifetime has been completely reached.')
ipspSaNegParamRefreshThresholdKB = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaNegParamRefreshThresholdKB.setStatus('current')
if mibBuilder.loadTexts: ipspSaNegParamRefreshThresholdKB.setDescription('ipspSaNegParamRefreshThresholdKB specifies what percentage of the kilobyte lifetime can expire before IKE should attempt to renegotiate the IPsec security association. A value between 1 and 100 representing a percentage. A value of 100 indicates that the IPsec security association should not be renegotiated until the kilobyte lifetime has been reached.')
ipspSaNegParamIdleDurationSecs = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 18, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaNegParamIdleDurationSecs.setStatus('current')
if mibBuilder.loadTexts: ipspSaNegParamIdleDurationSecs.setDescription('ipspSaNegParamIdleDurationSecs specifies how many seconds a security association may remain idle (i.e., no traffic protected using the security association) before it is deleted. A value of zero indicates that idle detection should not be used for the security association. Any non-zero value indicates the number of seconds the security association may remain unused.')
ipspSaNegParamLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 18, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspSaNegParamLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspSaNegParamLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspSaNegParamStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 18, 1, 8), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaNegParamStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspSaNegParamStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspSaNegParamRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 18, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspSaNegParamRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspSaNegParamRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. This object may not be set to destroy if refered to by other rows in other action tables.')
ipspIkeActionTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 19), )
if mibBuilder.loadTexts: ipspIkeActionTable.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActionTable.setDescription('The ipspIkeActionTable contains a list of the parameters used for an IKE phase 1 SA DOI negotiation. See the corresponding table ipspIkeActionProposalsTable for a list of proposals contained within a given IKE Action.')
ipspIkeActionEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 19, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspIkeActName"))
if mibBuilder.loadTexts: ipspIkeActionEntry.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActionEntry.setDescription('The ipspIkeActionEntry lists the IKE negotiation attributes.')
ipspIkeActName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 19, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspIkeActName.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActName.setDescription('This object contains the name of this ikeAction entry.')
ipspIkeActParametersName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 19, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkeActParametersName.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActParametersName.setDescription('This object is administratively assigned to reference a row in the ipspSaNegotiationParametersTable where additional parameters affecting this action may be found.')
ipspIkeActThresholdDerivedKeys = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 19, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(100)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkeActThresholdDerivedKeys.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActThresholdDerivedKeys.setDescription('ipspIkeActThresholdDerivedKeys specifies what percentage of the derived key limit (see the LifetimeDerivedKeys property of IKEProposal) can expire before IKE should attempt to renegotiate the IKE phase 1 security association.')
ipspIkeActExchangeMode = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 19, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("main", 1), ("agressive", 2))).clone('main')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkeActExchangeMode.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActExchangeMode.setDescription('ipspIkeActExchangeMode specifies the IKE Phase 1 negotiation mode.')
ipspIkeActAgressiveModeGroupId = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 19, 1, 5), IkeGroupDescription()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkeActAgressiveModeGroupId.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActAgressiveModeGroupId.setDescription('The values to be used for Diffie-Hellman exchange.')
ipspIkeActIdentityType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 19, 1, 6), IpsecDoiIdentType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkeActIdentityType.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActIdentityType.setDescription('This column along with ipspIkeActIdentityContext and endpoint information is used to refer an ipspIkeIdentityEntry in the ipspIkeIdentityTable.')
ipspIkeActIdentityContext = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 19, 1, 7), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkeActIdentityContext.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActIdentityContext.setDescription('This column, along with ipspIkeActIdentityType and endpoint information, is used to refer to an ipspIkeIdentityEntry in the ipspIkeIdentityTable.')
ipspIkeActPeerName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 19, 1, 8), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkeActPeerName.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActPeerName.setDescription('This object indicates the peer id name of the IKE peer. This object can be used to look up the peer id value, address, credentials and other values in the ipspPeerIdentityTable.')
ipspIkeActDoActionLogging = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 19, 1, 9), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkeActDoActionLogging.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActDoActionLogging.setDescription('ikeDoActionLogging specifies whether or not an audit message should be logged when this ike SA is created.')
ipspIkeActDoPacketLogging = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 19, 1, 10), IpspIPPacketLogging().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkeActDoPacketLogging.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActDoPacketLogging.setDescription('ikeDoPacketLogging specifies whether or not an audit message should be logged and if there is logging, how many bytes of the packet to place in the notification.')
ipspIkeActVendorId = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 19, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkeActVendorId.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActVendorId.setDescription('Vendor ID Payload. A value of NULL means that Vendor ID payload will be neither generated nor accepted. A non-NULL value means that a Vendor ID payload will be generated (when acting as an initiator) or is expected (when acting as a responder).')
ipspIkeActLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 19, 1, 12), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspIkeActLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspIkeActStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 19, 1, 13), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkeActStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspIkeActRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 19, 1, 14), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkeActRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. This object may not be set to destroy if refered to by other rows in other action tables.')
ipspIkeActionProposalsTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 20), )
if mibBuilder.loadTexts: ipspIkeActionProposalsTable.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActionProposalsTable.setDescription('This table contains a list of all ike proposal names found within a given IKE Action.')
ipspIkeActionProposalsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 20, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspIkeActName"), (0, "IPSEC-POLICY-MIB", "ipspIkeActPropPriority"))
if mibBuilder.loadTexts: ipspIkeActionProposalsEntry.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActionProposalsEntry.setDescription('a row containing one ike proposal reference')
ipspIkeActPropPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 20, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: ipspIkeActPropPriority.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActPropPriority.setDescription('The numeric priority of a given contained proposal inside an ike Action. This index should be used to order the proposals in an IKE Phase I negotiation, lowest value first.')
ipspIkeActPropName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 20, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkeActPropName.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActPropName.setDescription('The administratively assigned name that can be used to reference a set of values contained within the ipspIkeProposalTable.')
ipspIkeActPropLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 20, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspIkeActPropLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActPropLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspIkeActPropStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 20, 1, 4), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkeActPropStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActPropStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspIkeActPropRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 20, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkeActPropRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspIkeActPropRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified.')
ipspIkeProposalTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 21), )
if mibBuilder.loadTexts: ipspIkeProposalTable.setStatus('current')
if mibBuilder.loadTexts: ipspIkeProposalTable.setDescription('This table contains a list of IKE proposals which are used in an IKE negotiation.')
ipspIkeProposalEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 21, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspIkeActPropName"))
if mibBuilder.loadTexts: ipspIkeProposalEntry.setStatus('current')
if mibBuilder.loadTexts: ipspIkeProposalEntry.setDescription('One IKE proposal entry.')
ipspIkePropLifetimeDerivedKeys = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 21, 1, 1), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkePropLifetimeDerivedKeys.setStatus('current')
if mibBuilder.loadTexts: ipspIkePropLifetimeDerivedKeys.setDescription('ipspIkePropLifetimeDerivedKeys specifies the number of times that a phase 1 key will be used to derive a phase 2 key before the phase 1 security association needs renegotiated.')
ipspIkePropCipherAlgorithm = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 21, 1, 2), IkeEncryptionAlgorithm()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkePropCipherAlgorithm.setStatus('current')
if mibBuilder.loadTexts: ipspIkePropCipherAlgorithm.setDescription('ipspIkePropCipherAlgorithm specifies the proposed phase 1 security association encryption algorithm.')
ipspIkePropCipherKeyLength = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 21, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkePropCipherKeyLength.setStatus('current')
if mibBuilder.loadTexts: ipspIkePropCipherKeyLength.setDescription('This object specifies, in bits, the key length for the cipher algorithm used in IKE Phase 1 negotiation.')
ipspIkePropCipherKeyRounds = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 21, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkePropCipherKeyRounds.setStatus('current')
if mibBuilder.loadTexts: ipspIkePropCipherKeyRounds.setDescription('This object specifies the number of key rounds for the cipher algorithm used in IKE Phase 1 negotiation.')
ipspIkePropHashAlgorithm = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 21, 1, 5), IkeHashAlgorithm()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkePropHashAlgorithm.setStatus('current')
if mibBuilder.loadTexts: ipspIkePropHashAlgorithm.setDescription('ipspIkePropHashAlgorithm specifies the proposed phase 1 security assocation hash algorithm.')
ipspIkePropPrfAlgorithm = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 21, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("reserved", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkePropPrfAlgorithm.setStatus('current')
if mibBuilder.loadTexts: ipspIkePropPrfAlgorithm.setDescription('ipPRFAlgorithm specifies the proposed phase 1 security association psuedo-random function. Note: currently no prf algorithms are defined.')
ipspIkePropVendorId = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 21, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkePropVendorId.setStatus('current')
if mibBuilder.loadTexts: ipspIkePropVendorId.setDescription('The VendorID property is used to identify vendor-defined key exchange GroupIDs.')
ipspIkePropDhGroup = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 21, 1, 8), IkeGroupDescription()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkePropDhGroup.setStatus('current')
if mibBuilder.loadTexts: ipspIkePropDhGroup.setDescription('This object specifies the proposed phase 1 security association Diffie-Hellman group')
ipspIkePropAuthenticationMethod = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 21, 1, 9), IkeAuthMethod()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkePropAuthenticationMethod.setStatus('current')
if mibBuilder.loadTexts: ipspIkePropAuthenticationMethod.setDescription('This object specifies the proposed authentication method for the phase 1 security association.')
ipspIkePropMaxLifetimeSecs = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 21, 1, 10), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkePropMaxLifetimeSecs.setStatus('current')
if mibBuilder.loadTexts: ipspIkePropMaxLifetimeSecs.setDescription('ipspIkePropMaxLifetimeSecs specifies the maximum amount of time to propose a security association remain valid. A value of 0 indicates that the default lifetime of 8 hours should be used.')
ipspIkePropMaxLifetimeKB = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 21, 1, 11), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkePropMaxLifetimeKB.setStatus('current')
if mibBuilder.loadTexts: ipspIkePropMaxLifetimeKB.setDescription('ipspIkePropMaxLifetimeKB specifies the maximum kilobyte lifetime to propose a security association remain valid.')
ipspIkePropProposalLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 21, 1, 12), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspIkePropProposalLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspIkePropProposalLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspIkePropProposalStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 21, 1, 13), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkePropProposalStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspIkePropProposalStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspIkePropProposalRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 21, 1, 14), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkePropProposalRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspIkePropProposalRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified.')
ipspIpsecActionTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 22), )
if mibBuilder.loadTexts: ipspIpsecActionTable.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecActionTable.setDescription('The ipspIpsecActionTable contains a list of the parameters used for an IKE phase 2 IPsec DOI negotiation.')
ipspIpsecActionEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 22, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspIpsecActName"))
if mibBuilder.loadTexts: ipspIpsecActionEntry.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecActionEntry.setDescription('The ipspIpsecActionEntry lists the IPsec negotiation attributes.')
ipspIpsecActName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 22, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspIpsecActName.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecActName.setDescription('ipspIpsecActName is the name of the ipsecAction entry.')
ipspIpsecActParametersName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 22, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsecActParametersName.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecActParametersName.setDescription('This object is used to reference a row in the ipspSaNegotiationParametersTable where additional parameters affecting this action may be found.')
ipspIpsecActProposalsName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 22, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsecActProposalsName.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecActProposalsName.setDescription('This object is used to reference one or more rows in the ipspIpsecProposalsTable where an ordered list of proposals affecting this action may be found.')
ipspIpsecActUsePfs = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 22, 1, 4), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsecActUsePfs.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecActUsePfs.setDescription('This MIB object specifies whether or not perfect forward secrecy should be used when refreshing keys. A value of true indicates that PFS should be used.')
ipspIpsecActVendorId = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 22, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsecActVendorId.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecActVendorId.setDescription('The VendorID property is used to identify vendor-defined key exchange GroupIDs.')
ipspIpsecActGroupId = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 22, 1, 6), IkeGroupDescription()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsecActGroupId.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecActGroupId.setDescription('This object specifies the Diffie-Hellman group to use for phase 2 when the object ipspIpsecActUsePfs is true and the object ipspIpsecActUseIkeGroup is false. If the GroupID number is from the vendor-specific range (32768-65535), the VendorID qualifies the group number.')
ipspIpsecActPeerGatewayIdName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 22, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 116))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsecActPeerGatewayIdName.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecActPeerGatewayIdName.setDescription('This object indicates the peer id name of the peer gateway. This object can be used to look up the peer id value, address and other values in the ipspPeerIdentityTable. This object is used when initiating a tunnel SA. This object is not used for transport SAs. If no value is set and ipspIpsecActMode is tunnel, the peer gateway should be determined from the source or destination address of the packet.')
ipspIpsecActUseIkeGroup = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 22, 1, 8), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsecActUseIkeGroup.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecActUseIkeGroup.setDescription('This object specifies whether or not to use the same GroupId for phase 2 as was used in phase 1. If UsePFS is false, this entry should be ignored.')
ipspIpsecActGranularity = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 22, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("subnet", 1), ("address", 2), ("protocol", 3), ("port", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsecActGranularity.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecActGranularity.setDescription('This object specifies how the proposed selector for the security association will be created. The selector is created by using the FilterList information. The selector can be subnet, address, porotocol, or port.')
ipspIpsecActMode = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 22, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tunnel", 1), ("transport", 2))).clone('tunnel')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsecActMode.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecActMode.setDescription('This object specifies the encapsulation of the IPsec SA to be negotiated.')
ipspIpsecActDFHandling = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 22, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("copy", 1), ("set", 2), ("clear", 3))).clone('copy')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsecActDFHandling.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecActDFHandling.setDescription('This object specifies the processing of DF bit by the negotiated IPsec tunnel. 1 - DF bit is copied. 2 - DF bit is set. 3 - DF bit is cleared.')
ipspIpsecActDoActionLogging = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 22, 1, 12), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsecActDoActionLogging.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecActDoActionLogging.setDescription('ipspIpsecActDoActionLogging specifies whether or not an audit message should be logged when this ipsec SA is created.')
ipspIpsecActDoPacketLogging = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 22, 1, 13), IpspIPPacketLogging().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsecActDoPacketLogging.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecActDoPacketLogging.setDescription('ipspIpsecActDoPacketLogging specifies whether or not an audit message should be logged and if there is logging, how many bytes of the packet to place in the notification.')
ipspIpsecActLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 22, 1, 14), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspIpsecActLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecActLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspIpsecActStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 22, 1, 15), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsecActStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecActStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspIpsecActRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 22, 1, 16), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsecActRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecActRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object must remain active if it is referenced by a row in another table.')
ipspIpsecProposalsTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 23), )
if mibBuilder.loadTexts: ipspIpsecProposalsTable.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecProposalsTable.setDescription('This table lists one or more IPsec proposals for IPsec actions.')
ipspIpsecProposalsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 23, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspIpsecPropName"), (0, "IPSEC-POLICY-MIB", "ipspIpsecPropPriority"), (0, "IPSEC-POLICY-MIB", "ipspIpsecPropProtocolId"))
if mibBuilder.loadTexts: ipspIpsecProposalsEntry.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecProposalsEntry.setDescription('An entry containing (possibly a portion of) a proposal.')
ipspIpsecPropName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 23, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspIpsecPropName.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecPropName.setDescription('The name of this proposal.')
ipspIpsecPropPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 23, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: ipspIpsecPropPriority.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecPropPriority.setDescription('The priority level (AKA sequence level) of this proposal. A lower number indicates a higher precedence.')
ipspIpsecPropProtocolId = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 23, 1, 3), IpsecDoiSecProtocolId())
if mibBuilder.loadTexts: ipspIpsecPropProtocolId.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecPropProtocolId.setDescription('The protocol Id for the transforms for this proposal. The protoIsakmp(1) value is not valid for this object. This object, along with the ipspIpsecPropTransformsName, is the index into the ipspIpsecTransformsTable.')
ipspIpsecPropTransformsName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 23, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsecPropTransformsName.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecPropTransformsName.setDescription('The name of the transform or group of transforms for this protocol. This object, along with the ipspIpsecPropProtocolId, is the index into the ipspIpsecTransformsTable.')
ipspIpsecPropLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 23, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspIpsecPropLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecPropLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspIpsecPropStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 23, 1, 6), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsecPropStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecPropStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspIpsecPropRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 23, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsecPropRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecPropRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. This row may not be set to active until the corresponding row in the ipspIpsecTransformsTable exists and is active.')
ipspIpsecTransformsTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 24), )
if mibBuilder.loadTexts: ipspIpsecTransformsTable.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecTransformsTable.setDescription('This table lists the IPsec proposals contained within a given IPsec action and the transforms within each of those proposals. These proposals and transforms can then be used to create phase 2 negotiation proposals.')
ipspIpsecTransformsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 24, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspIpsecTranType"), (0, "IPSEC-POLICY-MIB", "ipspIpsecTranName"), (0, "IPSEC-POLICY-MIB", "ipspIpsecTranPriority"))
if mibBuilder.loadTexts: ipspIpsecTransformsEntry.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecTransformsEntry.setDescription('An entry containing the information on an IPsec transform.')
ipspIpsecTranType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 24, 1, 1), IpsecDoiSecProtocolId())
if mibBuilder.loadTexts: ipspIpsecTranType.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecTranType.setDescription('The protocol type for this transform. The protoIsakmp(1) value is not valid for this object.')
ipspIpsecTranName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 24, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspIpsecTranName.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecTranName.setDescription('The name for this transform or group of transforms.')
ipspIpsecTranPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 24, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: ipspIpsecTranPriority.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecTranPriority.setDescription('The priority level (AKA sequence level) of the this transform within the group of transforms. This indicates the preference for which algorithms are requested when the list of transforms are sent to the remote host. A lower number indicates a higher precedence.')
ipspIpsecTranTransformName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 24, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsecTranTransformName.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecTranTransformName.setDescription("The name for the given transform. Depending on the value of ipspIpsecTranType, this value should be used to lookup the transform's specific parameters in the ipspAhTransformTable, the ipspEspTransformTable or the ipspIpcompTransformTable.")
ipspIpsecTranLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 24, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspIpsecTranLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecTranLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspIpsecTranStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 24, 1, 6), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsecTranStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecTranStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspIpsecTranRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 24, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpsecTranRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecTranRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. This row may not be set to active until the corresponding row in the ipspAhTransformTable, ipspEspTransformTable or the ipspIpcompTransformTable exists.')
ipspAhTransformTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 25), )
if mibBuilder.loadTexts: ipspAhTransformTable.setStatus('current')
if mibBuilder.loadTexts: ipspAhTransformTable.setDescription('This table lists all the AH transforms which can be used to build IPsec proposals.')
ipspAhTransformEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 25, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspAhTranName"))
if mibBuilder.loadTexts: ipspAhTransformEntry.setStatus('current')
if mibBuilder.loadTexts: ipspAhTransformEntry.setDescription('This entry contains the attributes of one AH transform.')
ipspAhTranName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 25, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspAhTranName.setStatus('current')
if mibBuilder.loadTexts: ipspAhTranName.setDescription('This object contains the name of this AH transform. This row will be referred to by an ipspIpsecTransformsEntry.')
ipspAhTranMaxLifetimeSec = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 25, 1, 2), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspAhTranMaxLifetimeSec.setStatus('current')
if mibBuilder.loadTexts: ipspAhTranMaxLifetimeSec.setDescription('ipspAhTranMaxLifetimeSec specifies how long in seconds the security association derived from this transform should be used. A value of 0 indicates that the default lifetime of 8 hours should be used.')
ipspAhTranMaxLifetimeKB = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 25, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspAhTranMaxLifetimeKB.setStatus('current')
if mibBuilder.loadTexts: ipspAhTranMaxLifetimeKB.setDescription('ipspAhTranMaxLifetimeKB specifies how long in kilobytes the security association derived from this transform should be used.')
ipspAhTranAlgorithm = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 25, 1, 4), IpsecDoiAuthAlgorithm()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspAhTranAlgorithm.setStatus('current')
if mibBuilder.loadTexts: ipspAhTranAlgorithm.setDescription('This object specifies the AH algorithm for this transform.')
ipspAhTranReplayProtection = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 25, 1, 5), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspAhTranReplayProtection.setStatus('current')
if mibBuilder.loadTexts: ipspAhTranReplayProtection.setDescription('ipspAhTranReplayProtection indicates whether or not anti replay service is to be provided by this SA.')
ipspAhTranReplayWindowSize = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 25, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspAhTranReplayWindowSize.setStatus('current')
if mibBuilder.loadTexts: ipspAhTranReplayWindowSize.setDescription('ipspAhTranReplayWindowSize indicates the size, in bits, of the replay window to use if replay protection is true for this transform. The window size is assumed to be a power of two. If Replay Protection is false, this value can be ignored.')
ipspAhTranLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 25, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspAhTranLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspAhTranLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspAhTranStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 25, 1, 8), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspAhTranStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspAhTranStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspAhTranRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 25, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspAhTranRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspAhTranRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object must remain active if it is referenced by a row in another table.')
ipspEspTransformTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 26), )
if mibBuilder.loadTexts: ipspEspTransformTable.setStatus('current')
if mibBuilder.loadTexts: ipspEspTransformTable.setDescription('This table lists all the ESP transforms which can be used to build IPsec proposals')
ipspEspTransformEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 26, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspEspTranName"))
if mibBuilder.loadTexts: ipspEspTransformEntry.setStatus('current')
if mibBuilder.loadTexts: ipspEspTransformEntry.setDescription('This entry contains the attributes of one ESP transform.')
ipspEspTranName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 26, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspEspTranName.setStatus('current')
if mibBuilder.loadTexts: ipspEspTranName.setDescription('The name of this particular espTransform be referred to by an ipspIpsecTransformsEntry.')
ipspEspTranMaxLifetimeSec = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 26, 1, 2), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspEspTranMaxLifetimeSec.setStatus('current')
if mibBuilder.loadTexts: ipspEspTranMaxLifetimeSec.setDescription('ipspEspTranMaxLifetimeSec specifies how long in seconds the security association derived from this transform should be used. A value of 0 indicates that the default lifetime of 8 hours should be used.')
ipspEspTranMaxLifetimeKB = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 26, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspEspTranMaxLifetimeKB.setStatus('current')
if mibBuilder.loadTexts: ipspEspTranMaxLifetimeKB.setDescription('ipspEspTranMaxLifetimeKB specifies how long in kilobytes the security association derived from this transform should be used.')
ipspEspTranCipherTransformId = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 26, 1, 4), IpsecDoiEspTransform()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspEspTranCipherTransformId.setStatus('current')
if mibBuilder.loadTexts: ipspEspTranCipherTransformId.setDescription('This object specifies the transform ID of the ESP cipher algorithm.')
ipspEspTranCipherKeyLength = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 26, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspEspTranCipherKeyLength.setStatus('current')
if mibBuilder.loadTexts: ipspEspTranCipherKeyLength.setDescription('This object specifies, in bits, the key length for the ESP cipher algorithm.')
ipspEspTranCipherKeyRounds = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 26, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspEspTranCipherKeyRounds.setStatus('current')
if mibBuilder.loadTexts: ipspEspTranCipherKeyRounds.setDescription('This object specifies the number of key rounds for the ESP cipher algorithm.')
ipspEspTranIntegrityAlgorithmId = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 26, 1, 7), IpsecDoiAuthAlgorithm()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspEspTranIntegrityAlgorithmId.setStatus('current')
if mibBuilder.loadTexts: ipspEspTranIntegrityAlgorithmId.setDescription('This object specifies the ESP integrity algorithm ID.')
ipspEspTranReplayPrevention = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 26, 1, 8), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspEspTranReplayPrevention.setStatus('current')
if mibBuilder.loadTexts: ipspEspTranReplayPrevention.setDescription('ipspEspTranReplayPrevention indicates whether or not anti-replay service is to be provided by this SA.')
ipspEspTranReplayWindowSize = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 26, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspEspTranReplayWindowSize.setStatus('current')
if mibBuilder.loadTexts: ipspEspTranReplayWindowSize.setDescription('ipspEspTranReplayWindowSize indicates the size, in bits, of the replay window to use if replay protection is true for this transform. The window size is assumed to be a power of two. If Replay Protection is false, this value can be ignored.')
ipspEspTranLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 26, 1, 10), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspEspTranLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspEspTranLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspEspTranStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 26, 1, 11), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspEspTranStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspEspTranStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspEspTranRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 26, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspEspTranRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspEspTranRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object must remain active if it is referenced by a row in another table.')
ipspIpcompTransformTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 27), )
if mibBuilder.loadTexts: ipspIpcompTransformTable.setStatus('current')
if mibBuilder.loadTexts: ipspIpcompTransformTable.setDescription('This table lists all the IP compression transforms which can be used to build IPsec proposals during negotiation of a phase 2 SA.')
ipspIpcompTransformEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 27, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspIpcompTranName"))
if mibBuilder.loadTexts: ipspIpcompTransformEntry.setStatus('current')
if mibBuilder.loadTexts: ipspIpcompTransformEntry.setDescription('This entry contains the attributes of one IP compression transform.')
ipspIpcompTranName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 27, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspIpcompTranName.setStatus('current')
if mibBuilder.loadTexts: ipspIpcompTranName.setDescription('The name of this ipspIpcompTransformEntry.')
ipspIpcompTranMaxLifetimeSec = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 27, 1, 2), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpcompTranMaxLifetimeSec.setStatus('current')
if mibBuilder.loadTexts: ipspIpcompTranMaxLifetimeSec.setDescription('ipspIpcompTranMaxLifetimeSec specifies how long in seconds the security association derived from this transform should be used. A value of 0 indicates that the default lifetime of 8 hours should be used.')
ipspIpcompTranMaxLifetimeKB = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 27, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpcompTranMaxLifetimeKB.setStatus('current')
if mibBuilder.loadTexts: ipspIpcompTranMaxLifetimeKB.setDescription('ipspIpcompTranMaxLifetimeKB specifies how long in kilobytes the security association derived from this transform should be used.')
ipspIpcompTranAlgorithm = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 27, 1, 4), IpsecDoiIpcompTransform()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpcompTranAlgorithm.setStatus('current')
if mibBuilder.loadTexts: ipspIpcompTranAlgorithm.setDescription('ipspIpcompTranAlgorithm specifies the transform ID of the IP compression algorithm.')
ipspIpcompTranDictionarySize = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 27, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpcompTranDictionarySize.setStatus('current')
if mibBuilder.loadTexts: ipspIpcompTranDictionarySize.setDescription('If the algorithm in ipspIpcompTranAlgorithm requires a dictionary size configuration parameter, then this is the place to put it. This object specifies the log2 maximum size of the dictionary for the compression algorithm.')
ipspIpcompTranPrivateAlgorithm = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 27, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpcompTranPrivateAlgorithm.setStatus('current')
if mibBuilder.loadTexts: ipspIpcompTranPrivateAlgorithm.setDescription('If ipspIpcompTranPrivateAlgorithm has a value other zero, then it is up to the vendors implementation to determine the meaning of this field and substitute a data compression algorithm in place of ipspIpcompTranAlgorithm.')
ipspIpcompTranLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 27, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspIpcompTranLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspIpcompTranLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspIpcompTranStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 27, 1, 8), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpcompTranStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspIpcompTranStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspIpcompTranRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 27, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIpcompTranRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspIpcompTranRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object must remain active if it is referenced by a row in another table.')
ipspIkeIdentityTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 28), )
if mibBuilder.loadTexts: ipspIkeIdentityTable.setStatus('current')
if mibBuilder.loadTexts: ipspIkeIdentityTable.setDescription('IKEIdentity is used to represent the identities that may be used for an IPProtocolEndpoint (or collection of IPProtocolEndpoints) to identify itself in IKE phase 1 negotiations. The column ikeIdentityName in an ipspIkeActionEntry together with the ipspEndGroupIdentType and the ipspEndGroupAddress in the PolicyEndpointToGroupTable specifies the unique identity to use in a negotiation exchange.')
ipspIkeIdentityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 28, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspEndGroupIdentType"), (0, "IPSEC-POLICY-MIB", "ipspEndGroupAddress"), (0, "IPSEC-POLICY-MIB", "ipspIkeActIdentityType"), (0, "IPSEC-POLICY-MIB", "ipspIkeActIdentityContext"))
if mibBuilder.loadTexts: ipspIkeIdentityEntry.setStatus('current')
if mibBuilder.loadTexts: ipspIkeIdentityEntry.setDescription('ikeIdentity lists the attributes of an IKE identity.')
ipspIkeIdCredentialName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 28, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkeIdCredentialName.setStatus('current')
if mibBuilder.loadTexts: ipspIkeIdCredentialName.setDescription("This value is used as an index into the ipspCredentialTable to look up the actual credential value and other credential information. For ID's without associated credential information, this value is left blank. For ID's that are address types, this value may be left blank and the associated IPProtocolEndpoint or appropriate member of the Collection of endpoints is used.")
ipspIkeIdLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 28, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspIkeIdLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspIkeIdLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspIkeIdStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 28, 1, 3), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkeIdStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspIkeIdStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspIkeIdRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 28, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIkeIdRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspIkeIdRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object must remain active if it is referenced by a row in another table.')
ipspPeerIdentityTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 29), )
if mibBuilder.loadTexts: ipspPeerIdentityTable.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdentityTable.setDescription('PeerIdentity is used to represent the identities that may be used for peers to identify themselves in IKE phase I/II negotiations. PeerIdentityTable aggregates the table entries that provide mappings between identities and their addresses.')
ipspPeerIdentityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 29, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspPeerIdName"), (0, "IPSEC-POLICY-MIB", "ipspPeerIdPriority"))
if mibBuilder.loadTexts: ipspPeerIdentityEntry.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdentityEntry.setDescription("peerIdentity matches a peer's identity to its address.")
ipspPeerIdName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 29, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspPeerIdName.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdName.setDescription('This is an administratively assigned value that, together with ipspPeerIdPriority, uniquely identifies an entry in this table.')
ipspPeerIdPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 29, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: ipspPeerIdPriority.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdPriority.setDescription('This object, along with ipspPeerIdName, uniquely identifies an entry in this table. The priority also indicates the order of peer gateways to initiate or accept SAs from (i.e. try until success).')
ipspPeerIdType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 29, 1, 3), IpsecDoiIdentType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspPeerIdType.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdType.setDescription('ipspPeerIdType is an enumeration identifying the type of the Identity value.')
ipspPeerIdValue = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 29, 1, 4), IpspIdentityFilter()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspPeerIdValue.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdValue.setDescription('ipspPeerIdValue contains an Identity filter to be used to match against the identity payload in an IKE request. If this value matches the value in the identity payload, the credential for the peer can be found using the ipspPeerIdCredentialName as an index into the credential table.')
ipspPeerIdAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 29, 1, 5), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspPeerIdAddressType.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdAddressType.setDescription('The property ipspPeerIdAddressType specifies the format of the ipspPeerIdAddress property value.')
ipspPeerIdAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 29, 1, 6), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspPeerIdAddress.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdAddress.setDescription('The property PeerAddress specifies the IP address of the peer. The format is specified by the ipspPeerIdAddressType. Values of unknown, ipv4z, ipv6z and dns are not legal values for this object.')
ipspPeerIdCredentialName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 29, 1, 7), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspPeerIdCredentialName.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdCredentialName.setDescription('This value is used as an index into the ipspCredentialTable to look up the actual credential value and other credential information. For peer IDs that have no associated credential information, this value is left blank.')
ipspPeerIdLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 29, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspPeerIdLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspPeerIdStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 29, 1, 9), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspPeerIdStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspPeerIdRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 29, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspPeerIdRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object must remain active if it is referenced by a row in another table.')
ipspAutostartIkeTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 30), )
if mibBuilder.loadTexts: ipspAutostartIkeTable.setStatus('current')
if mibBuilder.loadTexts: ipspAutostartIkeTable.setDescription("The parameters in the autostart IKE Table are used to automatically initiate IKE phaes I and II (i.e. IPsec) negotiations on startup. It also will initiate IKE phase I and II negotiations for a row at the time of that row's creation")
ipspAutostartIkeEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 30, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspAutoIkePriority"))
if mibBuilder.loadTexts: ipspAutostartIkeEntry.setStatus('current')
if mibBuilder.loadTexts: ipspAutostartIkeEntry.setDescription("autostart ike provides the set of parameters to automatically start IKE and IPsec SA's.")
ipspAutoIkePriority = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 30, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: ipspAutoIkePriority.setStatus('current')
if mibBuilder.loadTexts: ipspAutoIkePriority.setDescription('ipspAutoIkePriority is an index into the autostartIkeAction table and can be used to order the autostart IKE actions.')
ipspAutoIkeAction = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 30, 1, 2), VariablePointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspAutoIkeAction.setStatus('current')
if mibBuilder.loadTexts: ipspAutoIkeAction.setDescription('This pointer is used to point to the action or compound action that should be initiated by this row.')
ipspAutoIkeAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 30, 1, 3), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspAutoIkeAddressType.setStatus('current')
if mibBuilder.loadTexts: ipspAutoIkeAddressType.setDescription('The property ipspAutoIkeAddressType specifies the format of the autoIke source and destination Address values. Values of unknown, ipv4z, ipv6z and dns are not legal values for this object.')
ipspAutoIkeSourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 30, 1, 4), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspAutoIkeSourceAddress.setStatus('current')
if mibBuilder.loadTexts: ipspAutoIkeSourceAddress.setDescription("The property autoIkeSourecAddress specifies Source IP address for autostarting IKE SA's, formatted according to the appropriate convention as defined in the ipspAutoIkeAddressType property.")
ipspAutoIkeSourcePort = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 30, 1, 5), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspAutoIkeSourcePort.setStatus('current')
if mibBuilder.loadTexts: ipspAutoIkeSourcePort.setDescription("The property ipspAutoIkeSourcePort specifies the port number for the source port for auotstarting IKE SA's. The value of 0 for this object is illegal.")
ipspAutoIkeDestAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 30, 1, 6), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspAutoIkeDestAddress.setStatus('current')
if mibBuilder.loadTexts: ipspAutoIkeDestAddress.setDescription("The property ipspAutoIkeDestAddress specifies the Destination IP address for autostarting IKE SA's, formatted according to the appropriate convention as defined in the ipspAutoIkeAddressType property.")
ipspAutoIkeDestPort = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 30, 1, 7), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspAutoIkeDestPort.setStatus('current')
if mibBuilder.loadTexts: ipspAutoIkeDestPort.setDescription("The property ipspAutoIkeDestPort specifies the port number for the destination port for auotstarting IKE SA's. The value of 0 for this object is illegal.")
ipspAutoIkeProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 30, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspAutoIkeProtocol.setStatus('current')
if mibBuilder.loadTexts: ipspAutoIkeProtocol.setDescription('The property Protocol specifies the protocol number used in comparing with policy filter entries and used in any phase 2 negotiations.')
ipspAutoIkeLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 30, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspAutoIkeLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspAutoIkeLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspAutoIkeStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 30, 1, 10), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspAutoIkeStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspAutoIkeStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspAutoIkeRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 30, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspAutoIkeRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspAutoIkeRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified.')
ipspIpsecCredMngServiceTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 31), )
if mibBuilder.loadTexts: ipspIpsecCredMngServiceTable.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecCredMngServiceTable.setDescription('A table of Credential Management Service values. This table is usually used for credential/certificate values that are used with a management service (e.g. Certificate Authorities).')
ipspIpsecCredMngServiceEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 31, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspIcmsName"))
if mibBuilder.loadTexts: ipspIpsecCredMngServiceEntry.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecCredMngServiceEntry.setDescription('A row in the ipspIpsecCredMngServiceTable.')
ipspIcmsName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 31, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspIcmsName.setStatus('current')
if mibBuilder.loadTexts: ipspIcmsName.setDescription('This is an administratively assigned string used to index this table.')
ipspIcmsDistinguishedName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 31, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 256))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIcmsDistinguishedName.setStatus('current')
if mibBuilder.loadTexts: ipspIcmsDistinguishedName.setDescription('This value represents the Distinguished Name of the Credential Management Service.')
ipspIcmsPolicyStatement = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 31, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIcmsPolicyStatement.setStatus('current')
if mibBuilder.loadTexts: ipspIcmsPolicyStatement.setDescription("This Value represents the Credential Management Service Policy Statement, or a reference describing how to obtain it (e.g., a URL). If one doesn't exist, this value can be left blank")
ipspIcmsMaxChainLength = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 31, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIcmsMaxChainLength.setStatus('current')
if mibBuilder.loadTexts: ipspIcmsMaxChainLength.setDescription('This value is the maximum length of the chain allowble from the Credential Management Service to the credential in question.')
ipspIcmsCredentialName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 31, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIcmsCredentialName.setStatus('current')
if mibBuilder.loadTexts: ipspIcmsCredentialName.setDescription('This value is used as an index into the ipspCredentialTable to look up the actual credential value.')
ipspIcmsLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 31, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspIcmsLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspIcmsLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspIcmsStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 31, 1, 7), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIcmsStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspIcmsStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspIcmsRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 31, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspIcmsRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspIcmsRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object must remain active if it is referenced by a row in another table.')
ipspCredMngCRLTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 32), )
if mibBuilder.loadTexts: ipspCredMngCRLTable.setStatus('current')
if mibBuilder.loadTexts: ipspCredMngCRLTable.setDescription('A table of the Credential Revocation Lists (CRL) for credential managment services.')
ipspCredMngCRLEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 32, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspIcmsName"), (0, "IPSEC-POLICY-MIB", "ipspCmcCRLName"))
if mibBuilder.loadTexts: ipspCredMngCRLEntry.setStatus('current')
if mibBuilder.loadTexts: ipspCredMngCRLEntry.setDescription('A row in the ipspCredMngCRLTable.')
ipspCmcCRLName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 32, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspCmcCRLName.setStatus('current')
if mibBuilder.loadTexts: ipspCmcCRLName.setDescription('This is an administratively assigned string used to index this table. It represents a CRL for a given CA from a given distribution point.')
ipspCmcDistributionPoint = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 32, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCmcDistributionPoint.setStatus('current')
if mibBuilder.loadTexts: ipspCmcDistributionPoint.setDescription('This Value represents a Distribution Point for a Credential Revocation List. It can be relative to the Credential Management Service or a full name (URL, e-mail, etc...).')
ipspCmcThisUpdate = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 32, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCmcThisUpdate.setStatus('current')
if mibBuilder.loadTexts: ipspCmcThisUpdate.setDescription('This value is the issue date of this CRL. This should be in utctime or generalizedtime.')
ipspCmcNextUpdate = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 32, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCmcNextUpdate.setStatus('current')
if mibBuilder.loadTexts: ipspCmcNextUpdate.setDescription('This value indicates the date the next version of this CRL will be issued. This should be in utctime or generalizedtime.')
ipspCmcLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 32, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspCmcLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspCmcLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspCmcStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 32, 1, 6), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCmcStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspCmcStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspCmcRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 32, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCmcRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspCmcRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object must remain active if it is referenced by a row in another table.')
ipspRevokedCertificateTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 33), )
if mibBuilder.loadTexts: ipspRevokedCertificateTable.setStatus('current')
if mibBuilder.loadTexts: ipspRevokedCertificateTable.setDescription("A table of Credentials revoked by credential managment services. That is, this table is a table of Certificates that are on CRL's, Credential Revocation Lists.")
ipspRevokedCertificateEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 33, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspCmcCRLName"), (0, "IPSEC-POLICY-MIB", "ipspRctCertSerialNumber"))
if mibBuilder.loadTexts: ipspRevokedCertificateEntry.setStatus('current')
if mibBuilder.loadTexts: ipspRevokedCertificateEntry.setDescription('A row in the ipspRevokedCertificateTable.')
ipspRctCertSerialNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 33, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)))
if mibBuilder.loadTexts: ipspRctCertSerialNumber.setStatus('current')
if mibBuilder.loadTexts: ipspRctCertSerialNumber.setDescription('This value is the serial number of the revoked certificate.')
ipspRctRevokedDate = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 33, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspRctRevokedDate.setStatus('current')
if mibBuilder.loadTexts: ipspRctRevokedDate.setDescription('This value is the revocation date of the certificate. This should be in utctime or generaltime.')
ipspRctRevokedReason = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 33, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("reserved", 0), ("unspecified", 1), ("keyCompromise", 2), ("cACompromise", 3), ("affiliationChanged", 4), ("superseded", 5), ("cessationOfOperation", 6), ("certificateHold", 7), ("removeFromCRL", 8))).clone('unspecified')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspRctRevokedReason.setStatus('current')
if mibBuilder.loadTexts: ipspRctRevokedReason.setDescription('This value is the reason this certificate was revoked.')
ipspRctLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 33, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspRctLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspRctLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspRctStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 33, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspRctStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspRctStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspRctRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 33, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspRctRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspRctRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object must remain active if it is referenced by a row in another table.')
ipspCredentialTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 34), )
if mibBuilder.loadTexts: ipspCredentialTable.setStatus('current')
if mibBuilder.loadTexts: ipspCredentialTable.setDescription('A table of credential values. Example of Credentials are shared secrets, certificates or kerberos tickets.')
ipspCredentialEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 34, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspCredName"))
if mibBuilder.loadTexts: ipspCredentialEntry.setStatus('current')
if mibBuilder.loadTexts: ipspCredentialEntry.setDescription('A row in the ipspCredentialTable.')
ipspCredName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 34, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipspCredName.setStatus('current')
if mibBuilder.loadTexts: ipspCredName.setDescription('This object represents the name for an entry in this table.')
ipspCredType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 34, 1, 2), IpspCredentialType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCredType.setStatus('current')
if mibBuilder.loadTexts: ipspCredType.setDescription('This object represents the type of the credential for this row.')
ipspCredCredential = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 34, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCredCredential.setStatus('current')
if mibBuilder.loadTexts: ipspCredCredential.setDescription('This object represents the credential value. If the size of the credential is greater than 1024, the credential must be configured via the ipspCredSegmentTable. For credential type where the disclosure of the credential would compromise the credential (e.g. shared secrets), when this object is accessed for reading, it MUST return a null length (0 length) string and MUST NOT return the configured credential.')
ipspCredSize = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 34, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspCredSize.setStatus('current')
if mibBuilder.loadTexts: ipspCredSize.setDescription('This value represents the size of the credential. If this value is greater than 1024, the ipspCreCredential column will return an empty (0 length) string. In this case, the value of the credential must be retrived from the ipspCredSegmentTable. For credential type where the disclosure of the credential would compromise the credential (e.g. shared secrets), when this object is accessed for reading, it MUST return a value of 0 and MUST NOT return the size credential.')
ipspCredMngName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 34, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCredMngName.setStatus('current')
if mibBuilder.loadTexts: ipspCredMngName.setDescription('This value is used as an index into the ipspIpsecCredMngServiceTable. For IDs that have no credential management service, this value is left blank.')
ipspCredRemoteID = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 34, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCredRemoteID.setStatus('current')
if mibBuilder.loadTexts: ipspCredRemoteID.setDescription('This object represents the Identification (e.g. user name) of the user of the key information on the remote site. If there is no ID associated with this credential, the value of this object should be the null string.')
ipspCredAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 34, 1, 7), IpspAdminStatus().clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCredAdminStatus.setStatus('current')
if mibBuilder.loadTexts: ipspCredAdminStatus.setDescription('Indicates whether this credential should be considered active. Rows with a disabled status must not be used for any purpose, including IKE or IPSEC processing. For credentials whose size does not execeed the maximum size for the ipspCredCredential, it may be set to enabled during row creation. For larger credentials, it should be left as disabled until all rows have been uploaded to the ipspCredSegmentTable.')
ipspCredLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 34, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspCredLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspCredLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means.')
ipspCredStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 34, 1, 9), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCredStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspCredStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process may have a storage type of readOnly or permanent.')
ipspCredRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 34, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCredRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspCredRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object must remain active if it is referenced by a row in another table.')
ipspCredentialSegmentTable = MibTable((1, 3, 6, 1, 2, 1, 153, 1, 35), )
if mibBuilder.loadTexts: ipspCredentialSegmentTable.setStatus('current')
if mibBuilder.loadTexts: ipspCredentialSegmentTable.setDescription('A table of credential segments. This table is used for credentials which are larger than the maximum size allowed for ipspCredCredential.')
ipspCredentialSegmentEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 1, 35, 1), ).setIndexNames((0, "IPSEC-POLICY-MIB", "ipspCredName"), (0, "IPSEC-POLICY-MIB", "ipspCredSegIndex"))
if mibBuilder.loadTexts: ipspCredentialSegmentEntry.setStatus('current')
if mibBuilder.loadTexts: ipspCredentialSegmentEntry.setDescription('A row in the ipspCredentialSegmentTable.')
ipspCredSegIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 35, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: ipspCredSegIndex.setStatus('current')
if mibBuilder.loadTexts: ipspCredSegIndex.setDescription("This object represents the segment number for this segment. By default, each segment will be 1024 octets. However, when this table is accessed using a context of 'ipsp4096', 'ipsp8192' or 'ipsp16384' a segment size of 4096, 8192 or 16384 (respectively) will be used instead. The number of rows which need to be retrieved or set can be calculated by obtaining the value of the ipspCredSize column from the corresponding ipspCredentialTable row and dividing it by the segment size.")
ipspCredSegValue = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 35, 1, 2), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCredSegValue.setStatus('current')
if mibBuilder.loadTexts: ipspCredSegValue.setDescription("This object represents one segment of the credential. By default, each complete segment will be 1024 octets. (The last row for a given credential might be smaller, if the credential size is not a multiple of the segment size). An implementation may optionally support segment sizes of 256, 4096, 8192 or the full object size when this table is is accessed using a context of 'ipspCred256', 'ipspCred4096', 'ipspCred8192' or 'ipspCredFull' (respectively). The number of rows which need to be retrieved or set can be calculated by obtaining the value of the ipspCredSize column from the corresponding ipspCredentialTable row and dividing it by the segment size.")
ipspCredSegLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 35, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspCredSegLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipspCredSegLastChanged.setDescription('The value of sysUpTime when this credential was last modified or created either through SNMP SETs or by some other external means. Note that the last changed type will be the same for all segemnts of the credential.')
ipspCredSegStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 35, 1, 4), StorageType().clone('nonVolatile')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspCredSegStorageType.setStatus('current')
if mibBuilder.loadTexts: ipspCredSegStorageType.setDescription('The storage type for this row. This object is read-only. Rows in this table have the same value as the ipspCredStorageType for the corresponding row in the ipspCredentialTable.')
ipspCredSegRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 1, 35, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipspCredSegRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipspCredSegRowStatus.setDescription('This object indicates the conceptual status of this row. The segment of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object must remain active if it is referenced by a row in another table.')
ipspNotificationVariables = MibIdentifier((1, 3, 6, 1, 2, 1, 153, 2, 1))
ipspNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 153, 2, 0))
ipspActionExecuted = MibScalar((1, 3, 6, 1, 2, 1, 153, 2, 1, 1), VariablePointer()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ipspActionExecuted.setStatus('current')
if mibBuilder.loadTexts: ipspActionExecuted.setDescription('Points to the action instance that was executed that resulted in the notification being sent.')
ipspIPInterfaceType = MibScalar((1, 3, 6, 1, 2, 1, 153, 2, 1, 2), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ipspIPInterfaceType.setStatus('current')
if mibBuilder.loadTexts: ipspIPInterfaceType.setDescription('Contains the interface type for the interface that the packet which triggered the notification in question is passing through.')
ipspIPInterfaceAddress = MibScalar((1, 3, 6, 1, 2, 1, 153, 2, 1, 3), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ipspIPInterfaceAddress.setStatus('current')
if mibBuilder.loadTexts: ipspIPInterfaceAddress.setDescription('Contains the interface address for the interface that the packet which triggered the notification in question is passing through.')
ipspIPSourceType = MibScalar((1, 3, 6, 1, 2, 1, 153, 2, 1, 4), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ipspIPSourceType.setStatus('current')
if mibBuilder.loadTexts: ipspIPSourceType.setDescription('Contains the source address type of the packet which triggered the notification in question.')
ipspIPSourceAddress = MibScalar((1, 3, 6, 1, 2, 1, 153, 2, 1, 5), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ipspIPSourceAddress.setStatus('current')
if mibBuilder.loadTexts: ipspIPSourceAddress.setDescription('Contains the source address of the packet which triggered the notification in question.')
ipspIPDestinationType = MibScalar((1, 3, 6, 1, 2, 1, 153, 2, 1, 6), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ipspIPDestinationType.setStatus('current')
if mibBuilder.loadTexts: ipspIPDestinationType.setDescription('Contains the destination address type of the packet which triggered the notification in question.')
ipspIPDestinationAddress = MibScalar((1, 3, 6, 1, 2, 1, 153, 2, 1, 7), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ipspIPDestinationAddress.setStatus('current')
if mibBuilder.loadTexts: ipspIPDestinationAddress.setDescription('Contains the destination address of the packet which triggered the notification in question.')
ipspPacketDirection = MibScalar((1, 3, 6, 1, 2, 1, 153, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inbound", 1), ("outbound", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ipspPacketDirection.setStatus('current')
if mibBuilder.loadTexts: ipspPacketDirection.setDescription('Indicates if the packet whic triggered the action in questions was inbound our outbound.')
ipspPacketPart = MibScalar((1, 3, 6, 1, 2, 1, 153, 2, 1, 9), OctetString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ipspPacketPart.setStatus('current')
if mibBuilder.loadTexts: ipspPacketPart.setDescription("Is the front part of the packet that triggered this notification. The size is determined by the value of 'IpspIPPacketLogging' or the size of the packet, whichever is smaller.")
ipspActionNotification = NotificationType((1, 3, 6, 1, 2, 1, 153, 2, 0, 1)).setObjects(("IPSEC-POLICY-MIB", "ipspActionExecuted"), ("IPSEC-POLICY-MIB", "ipspIPInterfaceType"), ("IPSEC-POLICY-MIB", "ipspIPInterfaceAddress"), ("IPSEC-POLICY-MIB", "ipspIPSourceType"), ("IPSEC-POLICY-MIB", "ipspIPSourceAddress"), ("IPSEC-POLICY-MIB", "ipspIPDestinationType"), ("IPSEC-POLICY-MIB", "ipspIPDestinationAddress"), ("IPSEC-POLICY-MIB", "ipspPacketDirection"))
if mibBuilder.loadTexts: ipspActionNotification.setStatus('current')
if mibBuilder.loadTexts: ipspActionNotification.setDescription('Notification that an action was executed by a rule. Only actions with logging enabled will result in this notification getting sent. The objects sent must include the ipspActionExecuted object which will indicate which action was executed within the scope of the rule. Additionally the ipspIPSourceType, ipspIPSourceAddress, ipspIPDestinationType, and ipspIPDestinationAddress objects must be included to indicate the packet source and destination of the packet that triggered the action. Finally the ipspIPInterfaceType, ipspIPInterfaceAddress, and ipspPacketDirection objects are included to indicate which interface the action was executed in association with and if the packet was inbound or outbond through the endpoint. Note that compound actions with multiple executed subactions may result in multiple notifications being sent from a single rule execution.')
ipspPacketNotification = NotificationType((1, 3, 6, 1, 2, 1, 153, 2, 0, 2)).setObjects(("IPSEC-POLICY-MIB", "ipspActionExecuted"), ("IPSEC-POLICY-MIB", "ipspIPInterfaceType"), ("IPSEC-POLICY-MIB", "ipspIPInterfaceAddress"), ("IPSEC-POLICY-MIB", "ipspIPSourceType"), ("IPSEC-POLICY-MIB", "ipspIPSourceAddress"), ("IPSEC-POLICY-MIB", "ipspIPDestinationType"), ("IPSEC-POLICY-MIB", "ipspIPDestinationAddress"), ("IPSEC-POLICY-MIB", "ipspPacketDirection"), ("IPSEC-POLICY-MIB", "ipspPacketPart"))
if mibBuilder.loadTexts: ipspPacketNotification.setStatus('current')
if mibBuilder.loadTexts: ipspPacketNotification.setDescription("Notification that a packet passed through an SA. Only SA's created by actions with packet logging enabled will result in this notification getting sent. The objects sent must include the ipspActionExecuted which will indicate which action was executed within the scope of the rule. Additionally, the ipspIPSourceType, ipspIPSourceAddress, ipspIPDestinationType, and ipspIPDestinationAddress, objects must be included to indicate the packet source and destination of the packet that triggered the action. The ipspIPInterfaceType, ipspIPInterfaceAddress, and ipspPacketDirection objects are included to indicate which endpoint the packet was associated with. Finally, ipspPacketPart is including for sending a variable sized part of the front of the packet depending on the value of IpspIPPacketLogging.")
ipspCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 153, 3, 1))
ipspGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 153, 3, 2))
ipspRuleFilterCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 153, 3, 1, 1)).setObjects(("IPSEC-POLICY-MIB", "ipspEndpointGroup"), ("IPSEC-POLICY-MIB", "ipspGroupContentsGroup"), ("IPSEC-POLICY-MIB", "ipspRuleDefinitionGroup"), ("IPSEC-POLICY-MIB", "ipspIPHeaderFilterGroup"), ("IPSEC-POLICY-MIB", "ipspStaticFilterGroup"), ("IPSEC-POLICY-MIB", "ipspIpsecSystemPolicyNameGroup"), ("IPSEC-POLICY-MIB", "ipspCompoundFilterGroup"), ("IPSEC-POLICY-MIB", "ipspIPOffsetFilterGroup"), ("IPSEC-POLICY-MIB", "ipspTimeFilterGroup"), ("IPSEC-POLICY-MIB", "ipspIpsoHeaderFilterGroup"), ("IPSEC-POLICY-MIB", "ipspCredentialFilterGroup"), ("IPSEC-POLICY-MIB", "ipspPeerIdFilterGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspRuleFilterCompliance = ipspRuleFilterCompliance.setStatus('current')
if mibBuilder.loadTexts: ipspRuleFilterCompliance.setDescription('The compliance statement for SNMP entities that include an IPsec MIB implementation with Endpoint, Rules, and filters support.')
ipspIPsecCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 153, 3, 1, 2)).setObjects(("IPSEC-POLICY-MIB", "ipspIpsecGroup"), ("IPSEC-POLICY-MIB", "ipspStaticActionGroup"), ("IPSEC-POLICY-MIB", "ipspPreconfiguredGroup"), ("IPSEC-POLICY-MIB", "ipspCompoundActionGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspIPsecCompliance = ipspIPsecCompliance.setStatus('current')
if mibBuilder.loadTexts: ipspIPsecCompliance.setDescription('The compliance statement for SNMP entities that include an IPsec MIB implementation and supports IPsec actions.')
ipspIKECompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 153, 3, 1, 3)).setObjects(("IPSEC-POLICY-MIB", "ipspIkeGroup"), ("IPSEC-POLICY-MIB", "ipspCompoundActionGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspIKECompliance = ipspIKECompliance.setStatus('current')
if mibBuilder.loadTexts: ipspIKECompliance.setDescription('The compliance statement for SNMP entities that include an IPsec MIB implementation and supports IKE actions.')
ipspLoggingCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 153, 3, 1, 4)).setObjects(("IPSEC-POLICY-MIB", "ipspActionLoggingObjectGroup"), ("IPSEC-POLICY-MIB", "ipspActionNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspLoggingCompliance = ipspLoggingCompliance.setStatus('current')
if mibBuilder.loadTexts: ipspLoggingCompliance.setDescription('The compliance statement for SNMP entities that support sending notifications when actions are invoked.')
ipspEndpointGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 153, 3, 2, 1)).setObjects(("IPSEC-POLICY-MIB", "ipspEndGroupName"), ("IPSEC-POLICY-MIB", "ipspEndGroupLastChanged"), ("IPSEC-POLICY-MIB", "ipspEndGroupStorageType"), ("IPSEC-POLICY-MIB", "ipspEndGroupRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspEndpointGroup = ipspEndpointGroup.setStatus('current')
if mibBuilder.loadTexts: ipspEndpointGroup.setDescription('The IPsec Policy Endpoint Table Group.')
ipspGroupContentsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 153, 3, 2, 2)).setObjects(("IPSEC-POLICY-MIB", "ipspGroupContComponentType"), ("IPSEC-POLICY-MIB", "ipspGroupContFilter"), ("IPSEC-POLICY-MIB", "ipspGroupContComponentName"), ("IPSEC-POLICY-MIB", "ipspGroupContLastChanged"), ("IPSEC-POLICY-MIB", "ipspGroupContStorageType"), ("IPSEC-POLICY-MIB", "ipspGroupContRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspGroupContentsGroup = ipspGroupContentsGroup.setStatus('current')
if mibBuilder.loadTexts: ipspGroupContentsGroup.setDescription('The IPsec Policy Group Contents Table Group.')
ipspIpsecSystemPolicyNameGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 153, 3, 2, 3)).setObjects(("IPSEC-POLICY-MIB", "ipspSystemPolicyGroupName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspIpsecSystemPolicyNameGroup = ipspIpsecSystemPolicyNameGroup.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecSystemPolicyNameGroup.setDescription('The System Policy Group Name Group.')
ipspRuleDefinitionGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 153, 3, 2, 4)).setObjects(("IPSEC-POLICY-MIB", "ipspRuleDefDescription"), ("IPSEC-POLICY-MIB", "ipspRuleDefFilter"), ("IPSEC-POLICY-MIB", "ipspRuleDefFilterNegated"), ("IPSEC-POLICY-MIB", "ipspRuleDefAction"), ("IPSEC-POLICY-MIB", "ipspRuleDefAdminStatus"), ("IPSEC-POLICY-MIB", "ipspRuleDefLastChanged"), ("IPSEC-POLICY-MIB", "ipspRuleDefStorageType"), ("IPSEC-POLICY-MIB", "ipspRuleDefRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspRuleDefinitionGroup = ipspRuleDefinitionGroup.setStatus('current')
if mibBuilder.loadTexts: ipspRuleDefinitionGroup.setDescription('The IPsec Policy Rule Definition Table Group.')
ipspCompoundFilterGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 153, 3, 2, 5)).setObjects(("IPSEC-POLICY-MIB", "ipspCompFiltDescription"), ("IPSEC-POLICY-MIB", "ipspCompFiltLogicType"), ("IPSEC-POLICY-MIB", "ipspCompFiltLastChanged"), ("IPSEC-POLICY-MIB", "ipspCompFiltStorageType"), ("IPSEC-POLICY-MIB", "ipspCompFiltRowStatus"), ("IPSEC-POLICY-MIB", "ipspSubFiltSubfilter"), ("IPSEC-POLICY-MIB", "ipspSubFiltSubfilterIsNegated"), ("IPSEC-POLICY-MIB", "ipspSubFiltLastChanged"), ("IPSEC-POLICY-MIB", "ipspSubFiltStorageType"), ("IPSEC-POLICY-MIB", "ipspSubFiltRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspCompoundFilterGroup = ipspCompoundFilterGroup.setStatus('current')
if mibBuilder.loadTexts: ipspCompoundFilterGroup.setDescription('The IPsec Policy Compound Filter Table and Filters in Compound Filters Table Group.')
ipspStaticFilterGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 153, 3, 2, 6)).setObjects(("IPSEC-POLICY-MIB", "ipspTrueFilter"), ("IPSEC-POLICY-MIB", "ipspIkePhase1Filter"), ("IPSEC-POLICY-MIB", "ipspIkePhase2Filter"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspStaticFilterGroup = ipspStaticFilterGroup.setStatus('current')
if mibBuilder.loadTexts: ipspStaticFilterGroup.setDescription('The static filter group. Currently this is just a true filter.')
ipspIPHeaderFilterGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 153, 3, 2, 7)).setObjects(("IPSEC-POLICY-MIB", "ipspIpHeadFiltType"), ("IPSEC-POLICY-MIB", "ipspIpHeadFiltIPVersion"), ("IPSEC-POLICY-MIB", "ipspIpHeadFiltSrcAddressBegin"), ("IPSEC-POLICY-MIB", "ipspIpHeadFiltSrcAddressEnd"), ("IPSEC-POLICY-MIB", "ipspIpHeadFiltDstAddressBegin"), ("IPSEC-POLICY-MIB", "ipspIpHeadFiltDstAddressEnd"), ("IPSEC-POLICY-MIB", "ipspIpHeadFiltSrcLowPort"), ("IPSEC-POLICY-MIB", "ipspIpHeadFiltSrcHighPort"), ("IPSEC-POLICY-MIB", "ipspIpHeadFiltDstLowPort"), ("IPSEC-POLICY-MIB", "ipspIpHeadFiltDstHighPort"), ("IPSEC-POLICY-MIB", "ipspIpHeadFiltProtocol"), ("IPSEC-POLICY-MIB", "ipspIpHeadFiltIPv6FlowLabel"), ("IPSEC-POLICY-MIB", "ipspIpHeadFiltLastChanged"), ("IPSEC-POLICY-MIB", "ipspIpHeadFiltStorageType"), ("IPSEC-POLICY-MIB", "ipspIpHeadFiltRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspIPHeaderFilterGroup = ipspIPHeaderFilterGroup.setStatus('current')
if mibBuilder.loadTexts: ipspIPHeaderFilterGroup.setDescription('The IPsec Policy IP Header Filter Table Group.')
ipspIPOffsetFilterGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 153, 3, 2, 8)).setObjects(("IPSEC-POLICY-MIB", "ipspIpOffFiltOffset"), ("IPSEC-POLICY-MIB", "ipspIpOffFiltType"), ("IPSEC-POLICY-MIB", "ipspIpOffFiltNumber"), ("IPSEC-POLICY-MIB", "ipspIpOffFiltValue"), ("IPSEC-POLICY-MIB", "ipspIpOffFiltLastChanged"), ("IPSEC-POLICY-MIB", "ipspIpOffFiltStorageType"), ("IPSEC-POLICY-MIB", "ipspIpOffFiltRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspIPOffsetFilterGroup = ipspIPOffsetFilterGroup.setStatus('current')
if mibBuilder.loadTexts: ipspIPOffsetFilterGroup.setDescription('The IPsec Policy IP Offset Filter Table Group.')
ipspTimeFilterGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 153, 3, 2, 9)).setObjects(("IPSEC-POLICY-MIB", "ipspTimeFiltPeriodStart"), ("IPSEC-POLICY-MIB", "ipspTimeFiltPeriodEnd"), ("IPSEC-POLICY-MIB", "ipspTimeFiltMonthOfYearMask"), ("IPSEC-POLICY-MIB", "ipspTimeFiltDayOfMonthMask"), ("IPSEC-POLICY-MIB", "ipspTimeFiltDayOfWeekMask"), ("IPSEC-POLICY-MIB", "ipspTimeFiltTimeOfDayMaskStart"), ("IPSEC-POLICY-MIB", "ipspTimeFiltTimeOfDayMaskEnd"), ("IPSEC-POLICY-MIB", "ipspTimeFiltLastChanged"), ("IPSEC-POLICY-MIB", "ipspTimeFiltStorageType"), ("IPSEC-POLICY-MIB", "ipspTimeFiltRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspTimeFilterGroup = ipspTimeFilterGroup.setStatus('current')
if mibBuilder.loadTexts: ipspTimeFilterGroup.setDescription('The IPsec Policy Time Filter Table Group.')
ipspIpsoHeaderFilterGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 153, 3, 2, 10)).setObjects(("IPSEC-POLICY-MIB", "ipspIpsoHeadFiltType"), ("IPSEC-POLICY-MIB", "ipspIpsoHeadFiltClassification"), ("IPSEC-POLICY-MIB", "ipspIpsoHeadFiltProtectionAuth"), ("IPSEC-POLICY-MIB", "ipspIpsoHeadFiltLastChanged"), ("IPSEC-POLICY-MIB", "ipspIpsoHeadFiltStorageType"), ("IPSEC-POLICY-MIB", "ipspIpsoHeadFiltRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspIpsoHeaderFilterGroup = ipspIpsoHeaderFilterGroup.setStatus('current')
if mibBuilder.loadTexts: ipspIpsoHeaderFilterGroup.setDescription('The IPsec Policy IPSO Header Filter Table Group.')
ipspCredentialFilterGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 153, 3, 2, 11)).setObjects(("IPSEC-POLICY-MIB", "ipspCredFiltCredentialType"), ("IPSEC-POLICY-MIB", "ipspCredFiltMatchFieldName"), ("IPSEC-POLICY-MIB", "ipspCredFiltMatchFieldValue"), ("IPSEC-POLICY-MIB", "ipspCredFiltAcceptCredFrom"), ("IPSEC-POLICY-MIB", "ipspCredFiltLastChanged"), ("IPSEC-POLICY-MIB", "ipspCredFiltStorageType"), ("IPSEC-POLICY-MIB", "ipspCredFiltRowStatus"), ("IPSEC-POLICY-MIB", "ipspCmcDistributionPoint"), ("IPSEC-POLICY-MIB", "ipspCmcThisUpdate"), ("IPSEC-POLICY-MIB", "ipspCmcNextUpdate"), ("IPSEC-POLICY-MIB", "ipspCmcLastChanged"), ("IPSEC-POLICY-MIB", "ipspCmcStorageType"), ("IPSEC-POLICY-MIB", "ipspCmcRowStatus"), ("IPSEC-POLICY-MIB", "ipspRctRevokedDate"), ("IPSEC-POLICY-MIB", "ipspRctRevokedReason"), ("IPSEC-POLICY-MIB", "ipspRctLastChanged"), ("IPSEC-POLICY-MIB", "ipspRctStorageType"), ("IPSEC-POLICY-MIB", "ipspRctRowStatus"), ("IPSEC-POLICY-MIB", "ipspIcmsDistinguishedName"), ("IPSEC-POLICY-MIB", "ipspIcmsPolicyStatement"), ("IPSEC-POLICY-MIB", "ipspIcmsMaxChainLength"), ("IPSEC-POLICY-MIB", "ipspIcmsCredentialName"), ("IPSEC-POLICY-MIB", "ipspIcmsLastChanged"), ("IPSEC-POLICY-MIB", "ipspIcmsStorageType"), ("IPSEC-POLICY-MIB", "ipspIcmsRowStatus"), ("IPSEC-POLICY-MIB", "ipspCredType"), ("IPSEC-POLICY-MIB", "ipspCredCredential"), ("IPSEC-POLICY-MIB", "ipspCredMngName"), ("IPSEC-POLICY-MIB", "ipspCredSize"), ("IPSEC-POLICY-MIB", "ipspCredRemoteID"), ("IPSEC-POLICY-MIB", "ipspCredAdminStatus"), ("IPSEC-POLICY-MIB", "ipspCredLastChanged"), ("IPSEC-POLICY-MIB", "ipspCredStorageType"), ("IPSEC-POLICY-MIB", "ipspCredRowStatus"), ("IPSEC-POLICY-MIB", "ipspCredSegValue"), ("IPSEC-POLICY-MIB", "ipspCredSegLastChanged"), ("IPSEC-POLICY-MIB", "ipspCredSegStorageType"), ("IPSEC-POLICY-MIB", "ipspCredSegRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspCredentialFilterGroup = ipspCredentialFilterGroup.setStatus('current')
if mibBuilder.loadTexts: ipspCredentialFilterGroup.setDescription('The IPsec Policy Credential Filter Table Group.')
ipspPeerIdFilterGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 153, 3, 2, 12)).setObjects(("IPSEC-POLICY-MIB", "ipspPeerIdFiltIdentityType"), ("IPSEC-POLICY-MIB", "ipspPeerIdFiltIdentityValue"), ("IPSEC-POLICY-MIB", "ipspPeerIdFiltLastChanged"), ("IPSEC-POLICY-MIB", "ipspPeerIdFiltStorageType"), ("IPSEC-POLICY-MIB", "ipspPeerIdFiltRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspPeerIdFilterGroup = ipspPeerIdFilterGroup.setStatus('current')
if mibBuilder.loadTexts: ipspPeerIdFilterGroup.setDescription('The IPsec Policy Peer Identity Filter Table Group.')
ipspCompoundActionGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 153, 3, 2, 13)).setObjects(("IPSEC-POLICY-MIB", "ipspCompActExecutionStrategy"), ("IPSEC-POLICY-MIB", "ipspCompActLastChanged"), ("IPSEC-POLICY-MIB", "ipspCompActStorageType"), ("IPSEC-POLICY-MIB", "ipspCompActRowStatus"), ("IPSEC-POLICY-MIB", "ipspSubActSubActionName"), ("IPSEC-POLICY-MIB", "aiipspCompActLastChanged"), ("IPSEC-POLICY-MIB", "aiipspCompActStorageType"), ("IPSEC-POLICY-MIB", "aiipspCompActRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspCompoundActionGroup = ipspCompoundActionGroup.setStatus('current')
if mibBuilder.loadTexts: ipspCompoundActionGroup.setDescription('The IPsec Policy Compound Action Table and Actions In Compound Action Table Group.')
ipspPreconfiguredGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 153, 3, 2, 14)).setObjects(("IPSEC-POLICY-MIB", "ipspSaPreActActionDescription"), ("IPSEC-POLICY-MIB", "ipspSaPreActActionLifetimeSec"), ("IPSEC-POLICY-MIB", "ipspSaPreActActionLifetimeKB"), ("IPSEC-POLICY-MIB", "ipspSaPreActDoActionLogging"), ("IPSEC-POLICY-MIB", "ipspSaPreActDoPacketLogging"), ("IPSEC-POLICY-MIB", "ipspSaPreActDFHandling"), ("IPSEC-POLICY-MIB", "ipspSaPreActActionType"), ("IPSEC-POLICY-MIB", "ipspSaPreActAHSPI"), ("IPSEC-POLICY-MIB", "ipspSaPreActAHTransformName"), ("IPSEC-POLICY-MIB", "ipspSaPreActAHSharedSecretName"), ("IPSEC-POLICY-MIB", "ipspSaPreActESPSPI"), ("IPSEC-POLICY-MIB", "ipspSaPreActESPTransformName"), ("IPSEC-POLICY-MIB", "ipspSaPreActESPEncSecretName"), ("IPSEC-POLICY-MIB", "ipspSaPreActESPAuthSecretName"), ("IPSEC-POLICY-MIB", "ipspSaPreActIPCompSPI"), ("IPSEC-POLICY-MIB", "ipspSaPreActIPCompTransformName"), ("IPSEC-POLICY-MIB", "ipspSaPreActPeerGatewayIdName"), ("IPSEC-POLICY-MIB", "ipspSaPreActLastChanged"), ("IPSEC-POLICY-MIB", "ipspSaPreActStorageType"), ("IPSEC-POLICY-MIB", "ipspSaPreActRowStatus"), ("IPSEC-POLICY-MIB", "ipspAhTranMaxLifetimeSec"), ("IPSEC-POLICY-MIB", "ipspAhTranMaxLifetimeKB"), ("IPSEC-POLICY-MIB", "ipspAhTranAlgorithm"), ("IPSEC-POLICY-MIB", "ipspAhTranReplayProtection"), ("IPSEC-POLICY-MIB", "ipspAhTranReplayWindowSize"), ("IPSEC-POLICY-MIB", "ipspAhTranLastChanged"), ("IPSEC-POLICY-MIB", "ipspAhTranStorageType"), ("IPSEC-POLICY-MIB", "ipspEspTranMaxLifetimeSec"), ("IPSEC-POLICY-MIB", "ipspEspTranMaxLifetimeKB"), ("IPSEC-POLICY-MIB", "ipspEspTranCipherTransformId"), ("IPSEC-POLICY-MIB", "ipspEspTranCipherKeyLength"), ("IPSEC-POLICY-MIB", "ipspEspTranCipherKeyRounds"), ("IPSEC-POLICY-MIB", "ipspEspTranIntegrityAlgorithmId"), ("IPSEC-POLICY-MIB", "ipspEspTranReplayPrevention"), ("IPSEC-POLICY-MIB", "ipspEspTranReplayWindowSize"), ("IPSEC-POLICY-MIB", "ipspEspTranLastChanged"), ("IPSEC-POLICY-MIB", "ipspEspTranStorageType"), ("IPSEC-POLICY-MIB", "ipspEspTranRowStatus"), ("IPSEC-POLICY-MIB", "ipspIpcompTranDictionarySize"), ("IPSEC-POLICY-MIB", "ipspIpcompTranMaxLifetimeSec"), ("IPSEC-POLICY-MIB", "ipspIpcompTranMaxLifetimeKB"), ("IPSEC-POLICY-MIB", "ipspIpcompTranPrivateAlgorithm"), ("IPSEC-POLICY-MIB", "ipspIpcompTranLastChanged"), ("IPSEC-POLICY-MIB", "ipspIpcompTranStorageType"), ("IPSEC-POLICY-MIB", "ipspIpcompTranRowStatus"), ("IPSEC-POLICY-MIB", "ipspPeerIdValue"), ("IPSEC-POLICY-MIB", "ipspPeerIdType"), ("IPSEC-POLICY-MIB", "ipspPeerIdAddress"), ("IPSEC-POLICY-MIB", "ipspPeerIdAddressType"), ("IPSEC-POLICY-MIB", "ipspPeerIdCredentialName"), ("IPSEC-POLICY-MIB", "ipspPeerIdLastChanged"), ("IPSEC-POLICY-MIB", "ipspPeerIdStorageType"), ("IPSEC-POLICY-MIB", "ipspPeerIdRowStatus"), ("IPSEC-POLICY-MIB", "ipspCredType"), ("IPSEC-POLICY-MIB", "ipspCredCredential"), ("IPSEC-POLICY-MIB", "ipspCredMngName"), ("IPSEC-POLICY-MIB", "ipspCredSize"), ("IPSEC-POLICY-MIB", "ipspCredRemoteID"), ("IPSEC-POLICY-MIB", "ipspCredAdminStatus"), ("IPSEC-POLICY-MIB", "ipspCredLastChanged"), ("IPSEC-POLICY-MIB", "ipspCredStorageType"), ("IPSEC-POLICY-MIB", "ipspCredRowStatus"), ("IPSEC-POLICY-MIB", "ipspCredSegValue"), ("IPSEC-POLICY-MIB", "ipspCredSegLastChanged"), ("IPSEC-POLICY-MIB", "ipspCredSegStorageType"), ("IPSEC-POLICY-MIB", "ipspCredSegRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspPreconfiguredGroup = ipspPreconfiguredGroup.setStatus('current')
if mibBuilder.loadTexts: ipspPreconfiguredGroup.setDescription('This group is the set of objects that support preconfigured IPsec actions. These objects are from The Preconfigured Action Table. This group also includes objects from the shared tables: Peer Identity Table, Credential Table, Credential Management Service Table and the AH, ESP, and IPComp Transform Tables.')
ipspStaticActionGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 153, 3, 2, 15)).setObjects(("IPSEC-POLICY-MIB", "ipspDropAction"), ("IPSEC-POLICY-MIB", "ipspAcceptAction"), ("IPSEC-POLICY-MIB", "ipspRejectIKEAction"), ("IPSEC-POLICY-MIB", "ipspDropActionLog"), ("IPSEC-POLICY-MIB", "ipspAcceptActionLog"), ("IPSEC-POLICY-MIB", "ipspRejectIKEActionLog"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspStaticActionGroup = ipspStaticActionGroup.setStatus('current')
if mibBuilder.loadTexts: ipspStaticActionGroup.setDescription('The IPsec Policy Static Actions Group.')
ipspIpsecGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 153, 3, 2, 16)).setObjects(("IPSEC-POLICY-MIB", "ipspIpsecActParametersName"), ("IPSEC-POLICY-MIB", "ipspIpsecActProposalsName"), ("IPSEC-POLICY-MIB", "ipspIpsecActUsePfs"), ("IPSEC-POLICY-MIB", "ipspIpsecActVendorId"), ("IPSEC-POLICY-MIB", "ipspIpsecActGroupId"), ("IPSEC-POLICY-MIB", "ipspIpsecActPeerGatewayIdName"), ("IPSEC-POLICY-MIB", "ipspIpsecActUseIkeGroup"), ("IPSEC-POLICY-MIB", "ipspIpsecActGranularity"), ("IPSEC-POLICY-MIB", "ipspIpsecActMode"), ("IPSEC-POLICY-MIB", "ipspIpsecActDFHandling"), ("IPSEC-POLICY-MIB", "ipspIpsecActDoActionLogging"), ("IPSEC-POLICY-MIB", "ipspIpsecActDoPacketLogging"), ("IPSEC-POLICY-MIB", "ipspIpsecActLastChanged"), ("IPSEC-POLICY-MIB", "ipspIpsecActStorageType"), ("IPSEC-POLICY-MIB", "ipspIpsecActRowStatus"), ("IPSEC-POLICY-MIB", "ipspIpsecPropTransformsName"), ("IPSEC-POLICY-MIB", "ipspIpsecPropLastChanged"), ("IPSEC-POLICY-MIB", "ipspIpsecPropStorageType"), ("IPSEC-POLICY-MIB", "ipspIpsecPropRowStatus"), ("IPSEC-POLICY-MIB", "ipspIpsecTranTransformName"), ("IPSEC-POLICY-MIB", "ipspIpsecTranLastChanged"), ("IPSEC-POLICY-MIB", "ipspIpsecTranStorageType"), ("IPSEC-POLICY-MIB", "ipspIpsecTranRowStatus"), ("IPSEC-POLICY-MIB", "ipspSaNegParamMinLifetimeSecs"), ("IPSEC-POLICY-MIB", "ipspSaNegParamMinLifetimeKB"), ("IPSEC-POLICY-MIB", "ipspSaNegParamRefreshThreshSecs"), ("IPSEC-POLICY-MIB", "ipspSaNegParamRefreshThresholdKB"), ("IPSEC-POLICY-MIB", "ipspSaNegParamIdleDurationSecs"), ("IPSEC-POLICY-MIB", "ipspSaNegParamLastChanged"), ("IPSEC-POLICY-MIB", "ipspSaNegParamStorageType"), ("IPSEC-POLICY-MIB", "ipspSaNegParamRowStatus"), ("IPSEC-POLICY-MIB", "ipspAhTranMaxLifetimeSec"), ("IPSEC-POLICY-MIB", "ipspAhTranMaxLifetimeKB"), ("IPSEC-POLICY-MIB", "ipspAhTranAlgorithm"), ("IPSEC-POLICY-MIB", "ipspAhTranReplayProtection"), ("IPSEC-POLICY-MIB", "ipspAhTranReplayWindowSize"), ("IPSEC-POLICY-MIB", "ipspAhTranLastChanged"), ("IPSEC-POLICY-MIB", "ipspAhTranStorageType"), ("IPSEC-POLICY-MIB", "ipspAhTranRowStatus"), ("IPSEC-POLICY-MIB", "ipspEspTranMaxLifetimeSec"), ("IPSEC-POLICY-MIB", "ipspEspTranMaxLifetimeKB"), ("IPSEC-POLICY-MIB", "ipspEspTranCipherTransformId"), ("IPSEC-POLICY-MIB", "ipspEspTranCipherKeyLength"), ("IPSEC-POLICY-MIB", "ipspEspTranCipherKeyRounds"), ("IPSEC-POLICY-MIB", "ipspEspTranIntegrityAlgorithmId"), ("IPSEC-POLICY-MIB", "ipspEspTranReplayPrevention"), ("IPSEC-POLICY-MIB", "ipspEspTranReplayWindowSize"), ("IPSEC-POLICY-MIB", "ipspEspTranLastChanged"), ("IPSEC-POLICY-MIB", "ipspEspTranStorageType"), ("IPSEC-POLICY-MIB", "ipspEspTranRowStatus"), ("IPSEC-POLICY-MIB", "ipspIpcompTranDictionarySize"), ("IPSEC-POLICY-MIB", "ipspIpcompTranAlgorithm"), ("IPSEC-POLICY-MIB", "ipspIpcompTranMaxLifetimeSec"), ("IPSEC-POLICY-MIB", "ipspIpcompTranMaxLifetimeKB"), ("IPSEC-POLICY-MIB", "ipspIpcompTranPrivateAlgorithm"), ("IPSEC-POLICY-MIB", "ipspIpcompTranLastChanged"), ("IPSEC-POLICY-MIB", "ipspIpcompTranStorageType"), ("IPSEC-POLICY-MIB", "ipspIpcompTranRowStatus"), ("IPSEC-POLICY-MIB", "ipspPeerIdValue"), ("IPSEC-POLICY-MIB", "ipspPeerIdType"), ("IPSEC-POLICY-MIB", "ipspPeerIdAddress"), ("IPSEC-POLICY-MIB", "ipspPeerIdAddressType"), ("IPSEC-POLICY-MIB", "ipspPeerIdCredentialName"), ("IPSEC-POLICY-MIB", "ipspPeerIdLastChanged"), ("IPSEC-POLICY-MIB", "ipspPeerIdStorageType"), ("IPSEC-POLICY-MIB", "ipspPeerIdRowStatus"), ("IPSEC-POLICY-MIB", "ipspCredType"), ("IPSEC-POLICY-MIB", "ipspCredCredential"), ("IPSEC-POLICY-MIB", "ipspCredMngName"), ("IPSEC-POLICY-MIB", "ipspCredSize"), ("IPSEC-POLICY-MIB", "ipspCredRemoteID"), ("IPSEC-POLICY-MIB", "ipspCredAdminStatus"), ("IPSEC-POLICY-MIB", "ipspCredLastChanged"), ("IPSEC-POLICY-MIB", "ipspCredStorageType"), ("IPSEC-POLICY-MIB", "ipspCredRowStatus"), ("IPSEC-POLICY-MIB", "ipspCredSegValue"), ("IPSEC-POLICY-MIB", "ipspCredSegLastChanged"), ("IPSEC-POLICY-MIB", "ipspCredSegStorageType"), ("IPSEC-POLICY-MIB", "ipspCredSegRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspIpsecGroup = ipspIpsecGroup.setStatus('current')
if mibBuilder.loadTexts: ipspIpsecGroup.setDescription('This group is the set of objects that support IPsec actions. These objects are from The IPsec Policy IPsec Actions Table, The IPsec Proposal Table, and The IPsec Transform Table. This group also includes objects from the shared tables: Peer Identity Table, Credential Table, Negotiation Parameters Table, Credential Management Service Table and the AH, ESP, and IPComp Transform Table.')
ipspIkeGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 153, 3, 2, 17)).setObjects(("IPSEC-POLICY-MIB", "ipspIkeActParametersName"), ("IPSEC-POLICY-MIB", "ipspIkeActThresholdDerivedKeys"), ("IPSEC-POLICY-MIB", "ipspIkeActExchangeMode"), ("IPSEC-POLICY-MIB", "ipspIkeActAgressiveModeGroupId"), ("IPSEC-POLICY-MIB", "ipspIkeActIdentityType"), ("IPSEC-POLICY-MIB", "ipspIkeActIdentityContext"), ("IPSEC-POLICY-MIB", "ipspIkeActPeerName"), ("IPSEC-POLICY-MIB", "ipspIkeActVendorId"), ("IPSEC-POLICY-MIB", "ipspIkeActPropName"), ("IPSEC-POLICY-MIB", "ipspIkeActDoActionLogging"), ("IPSEC-POLICY-MIB", "ipspIkeActDoPacketLogging"), ("IPSEC-POLICY-MIB", "ipspIkeActLastChanged"), ("IPSEC-POLICY-MIB", "ipspIkeActStorageType"), ("IPSEC-POLICY-MIB", "ipspIkeActRowStatus"), ("IPSEC-POLICY-MIB", "ipspIkeActPropLastChanged"), ("IPSEC-POLICY-MIB", "ipspIkeActPropStorageType"), ("IPSEC-POLICY-MIB", "ipspIkeActPropRowStatus"), ("IPSEC-POLICY-MIB", "ipspIkePropLifetimeDerivedKeys"), ("IPSEC-POLICY-MIB", "ipspIkePropCipherAlgorithm"), ("IPSEC-POLICY-MIB", "ipspIkePropCipherKeyLength"), ("IPSEC-POLICY-MIB", "ipspIkePropCipherKeyRounds"), ("IPSEC-POLICY-MIB", "ipspIkePropHashAlgorithm"), ("IPSEC-POLICY-MIB", "ipspIkePropPrfAlgorithm"), ("IPSEC-POLICY-MIB", "ipspIkePropVendorId"), ("IPSEC-POLICY-MIB", "ipspIkePropDhGroup"), ("IPSEC-POLICY-MIB", "ipspIkePropAuthenticationMethod"), ("IPSEC-POLICY-MIB", "ipspIkePropMaxLifetimeSecs"), ("IPSEC-POLICY-MIB", "ipspIkePropMaxLifetimeKB"), ("IPSEC-POLICY-MIB", "ipspIkePropProposalLastChanged"), ("IPSEC-POLICY-MIB", "ipspIkePropProposalStorageType"), ("IPSEC-POLICY-MIB", "ipspIkePropProposalRowStatus"), ("IPSEC-POLICY-MIB", "ipspSaNegParamMinLifetimeSecs"), ("IPSEC-POLICY-MIB", "ipspSaNegParamMinLifetimeKB"), ("IPSEC-POLICY-MIB", "ipspSaNegParamRefreshThreshSecs"), ("IPSEC-POLICY-MIB", "ipspSaNegParamRefreshThresholdKB"), ("IPSEC-POLICY-MIB", "ipspSaNegParamIdleDurationSecs"), ("IPSEC-POLICY-MIB", "ipspSaNegParamLastChanged"), ("IPSEC-POLICY-MIB", "ipspSaNegParamStorageType"), ("IPSEC-POLICY-MIB", "ipspSaNegParamRowStatus"), ("IPSEC-POLICY-MIB", "ipspIkeIdCredentialName"), ("IPSEC-POLICY-MIB", "ipspIkeIdLastChanged"), ("IPSEC-POLICY-MIB", "ipspIkeIdStorageType"), ("IPSEC-POLICY-MIB", "ipspIkeIdRowStatus"), ("IPSEC-POLICY-MIB", "ipspAutoIkeAction"), ("IPSEC-POLICY-MIB", "ipspAutoIkeAddressType"), ("IPSEC-POLICY-MIB", "ipspAutoIkeSourceAddress"), ("IPSEC-POLICY-MIB", "ipspAutoIkeSourcePort"), ("IPSEC-POLICY-MIB", "ipspAutoIkeDestAddress"), ("IPSEC-POLICY-MIB", "ipspAutoIkeDestPort"), ("IPSEC-POLICY-MIB", "ipspAutoIkeProtocol"), ("IPSEC-POLICY-MIB", "ipspAutoIkeLastChanged"), ("IPSEC-POLICY-MIB", "ipspAutoIkeStorageType"), ("IPSEC-POLICY-MIB", "ipspAutoIkeRowStatus"), ("IPSEC-POLICY-MIB", "ipspPeerIdValue"), ("IPSEC-POLICY-MIB", "ipspPeerIdType"), ("IPSEC-POLICY-MIB", "ipspPeerIdAddress"), ("IPSEC-POLICY-MIB", "ipspPeerIdAddressType"), ("IPSEC-POLICY-MIB", "ipspPeerIdCredentialName"), ("IPSEC-POLICY-MIB", "ipspPeerIdLastChanged"), ("IPSEC-POLICY-MIB", "ipspPeerIdStorageType"), ("IPSEC-POLICY-MIB", "ipspPeerIdRowStatus"), ("IPSEC-POLICY-MIB", "ipspCmcDistributionPoint"), ("IPSEC-POLICY-MIB", "ipspCmcThisUpdate"), ("IPSEC-POLICY-MIB", "ipspCmcNextUpdate"), ("IPSEC-POLICY-MIB", "ipspCmcLastChanged"), ("IPSEC-POLICY-MIB", "ipspCmcStorageType"), ("IPSEC-POLICY-MIB", "ipspCmcRowStatus"), ("IPSEC-POLICY-MIB", "ipspRctRevokedDate"), ("IPSEC-POLICY-MIB", "ipspRctRevokedReason"), ("IPSEC-POLICY-MIB", "ipspRctLastChanged"), ("IPSEC-POLICY-MIB", "ipspRctStorageType"), ("IPSEC-POLICY-MIB", "ipspRctRowStatus"), ("IPSEC-POLICY-MIB", "ipspIcmsDistinguishedName"), ("IPSEC-POLICY-MIB", "ipspIcmsPolicyStatement"), ("IPSEC-POLICY-MIB", "ipspIcmsMaxChainLength"), ("IPSEC-POLICY-MIB", "ipspIcmsCredentialName"), ("IPSEC-POLICY-MIB", "ipspIcmsLastChanged"), ("IPSEC-POLICY-MIB", "ipspIcmsStorageType"), ("IPSEC-POLICY-MIB", "ipspIcmsRowStatus"), ("IPSEC-POLICY-MIB", "ipspCredType"), ("IPSEC-POLICY-MIB", "ipspCredCredential"), ("IPSEC-POLICY-MIB", "ipspCredMngName"), ("IPSEC-POLICY-MIB", "ipspCredSize"), ("IPSEC-POLICY-MIB", "ipspCredRemoteID"), ("IPSEC-POLICY-MIB", "ipspCredAdminStatus"), ("IPSEC-POLICY-MIB", "ipspCredLastChanged"), ("IPSEC-POLICY-MIB", "ipspCredStorageType"), ("IPSEC-POLICY-MIB", "ipspCredRowStatus"), ("IPSEC-POLICY-MIB", "ipspCredSegValue"), ("IPSEC-POLICY-MIB", "ipspCredSegLastChanged"), ("IPSEC-POLICY-MIB", "ipspCredSegStorageType"), ("IPSEC-POLICY-MIB", "ipspCredSegRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspIkeGroup = ipspIkeGroup.setStatus('current')
if mibBuilder.loadTexts: ipspIkeGroup.setDescription('This group is the set of objects that support IKE actions. These objects are from The IPsec Policy IKE Action Table, The IKE Action Proposals Table, The IKE Proposal Table, The autostart IKE Table and The IKE Identity Table. This group also includes objects from the shared tables: Peer Identity Table, Credential Management Service Table and Negotiation Parameters Table.')
ipspActionLoggingObjectGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 153, 3, 2, 18)).setObjects(("IPSEC-POLICY-MIB", "ipspActionExecuted"), ("IPSEC-POLICY-MIB", "ipspIPInterfaceType"), ("IPSEC-POLICY-MIB", "ipspIPInterfaceAddress"), ("IPSEC-POLICY-MIB", "ipspIPSourceType"), ("IPSEC-POLICY-MIB", "ipspIPSourceAddress"), ("IPSEC-POLICY-MIB", "ipspIPDestinationType"), ("IPSEC-POLICY-MIB", "ipspIPDestinationAddress"), ("IPSEC-POLICY-MIB", "ipspPacketDirection"), ("IPSEC-POLICY-MIB", "ipspPacketPart"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspActionLoggingObjectGroup = ipspActionLoggingObjectGroup.setStatus('current')
if mibBuilder.loadTexts: ipspActionLoggingObjectGroup.setDescription('Notification objects.')
ipspActionNotificationGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 153, 3, 2, 19)).setObjects(("IPSEC-POLICY-MIB", "ipspActionNotification"), ("IPSEC-POLICY-MIB", "ipspPacketNotification"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipspActionNotificationGroup = ipspActionNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: ipspActionNotificationGroup.setDescription('Notifications.')
mibBuilder.exportSymbols("IPSEC-POLICY-MIB", ipspIpsecTranName=ipspIpsecTranName, ipspIpOffFiltLastChanged=ipspIpOffFiltLastChanged, ipspPeerIdFiltIdentityValue=ipspPeerIdFiltIdentityValue, ipspGroupContLastChanged=ipspGroupContLastChanged, ipspRuleDefFilter=ipspRuleDefFilter, ipspSaNegParamRefreshThreshSecs=ipspSaNegParamRefreshThreshSecs, ipspGroups=ipspGroups, ipspSaPreActIPCompSPI=ipspSaPreActIPCompSPI, ipspIpOffsetFilterEntry=ipspIpOffsetFilterEntry, ipspSaPreActDFHandling=ipspSaPreActDFHandling, ipspSaPreActAHTransformName=ipspSaPreActAHTransformName, ipspEspTranReplayPrevention=ipspEspTranReplayPrevention, ipspCmcStorageType=ipspCmcStorageType, ipspActionLoggingObjectGroup=ipspActionLoggingObjectGroup, ipspEndGroupAddress=ipspEndGroupAddress, ipspGroupContentsTable=ipspGroupContentsTable, ipspCompoundActionEntry=ipspCompoundActionEntry, ipspIkeActDoActionLogging=ipspIkeActDoActionLogging, ipspIpHeadFiltSrcLowPort=ipspIpHeadFiltSrcLowPort, ipspAutoIkeStorageType=ipspAutoIkeStorageType, ipspEndGroupStorageType=ipspEndGroupStorageType, ipspCredentialFilterEntry=ipspCredentialFilterEntry, ipspPeerIdFiltStorageType=ipspPeerIdFiltStorageType, ipspTimeFiltPeriodEnd=ipspTimeFiltPeriodEnd, ipspSaPreActESPSPI=ipspSaPreActESPSPI, ipspIkeActionEntry=ipspIkeActionEntry, ipspPeerIdStorageType=ipspPeerIdStorageType, ipspAcceptActionLog=ipspAcceptActionLog, ipspIpsoHeaderFilterGroup=ipspIpsoHeaderFilterGroup, ipspCredSegRowStatus=ipspCredSegRowStatus, ipspIpHeadFiltDstAddressEnd=ipspIpHeadFiltDstAddressEnd, ipspIkeIdentityTable=ipspIkeIdentityTable, ipspAutostartIkeEntry=ipspAutostartIkeEntry, ipspIpsecTranLastChanged=ipspIpsecTranLastChanged, ipspCompActName=ipspCompActName, ipspCompActExecutionStrategy=ipspCompActExecutionStrategy, ipspAutoIkeSourcePort=ipspAutoIkeSourcePort, ipspIpcompTranRowStatus=ipspIpcompTranRowStatus, ipspIkePropDhGroup=ipspIkePropDhGroup, ipspSubActPriority=ipspSubActPriority, ipspIkeProposalTable=ipspIkeProposalTable, ipspGroupContentsEntry=ipspGroupContentsEntry, ipspCredFiltCredentialType=ipspCredFiltCredentialType, ipspIkeActPropLastChanged=ipspIkeActPropLastChanged, IpspSADirection=IpspSADirection, ipspTimeFilterEntry=ipspTimeFilterEntry, ipspCmcNextUpdate=ipspCmcNextUpdate, ipspTimeFiltLastChanged=ipspTimeFiltLastChanged, ipspSaNegParamStorageType=ipspSaNegParamStorageType, ipspRuleDefFilterNegated=ipspRuleDefFilterNegated, ipspCompFiltRowStatus=ipspCompFiltRowStatus, IpspBooleanOperator=IpspBooleanOperator, aiipspCompActLastChanged=aiipspCompActLastChanged, ipspIkeActPropPriority=ipspIkeActPropPriority, ipspIpsecActionTable=ipspIpsecActionTable, ipspIkeActName=ipspIkeActName, ipspCredFiltMatchFieldValue=ipspCredFiltMatchFieldValue, ipspAutoIkeAction=ipspAutoIkeAction, ipspPeerIdAddressType=ipspPeerIdAddressType, ipspEspTranMaxLifetimeSec=ipspEspTranMaxLifetimeSec, ipspPeerIdentityFilterEntry=ipspPeerIdentityFilterEntry, ipspCompliances=ipspCompliances, ipspSaPreActAHSharedSecretName=ipspSaPreActAHSharedSecretName, ipspIkeActStorageType=ipspIkeActStorageType, ipspAhTranMaxLifetimeSec=ipspAhTranMaxLifetimeSec, PYSNMP_MODULE_ID=ipspMIB, ipspRevokedCertificateTable=ipspRevokedCertificateTable, ipspIkePhase2Filter=ipspIkePhase2Filter, ipspNotificationObjects=ipspNotificationObjects, ipspIkeIdRowStatus=ipspIkeIdRowStatus, ipspConfigObjects=ipspConfigObjects, ipspRuleDefLastChanged=ipspRuleDefLastChanged, ipspCredFiltAcceptCredFrom=ipspCredFiltAcceptCredFrom, ipspAutostartIkeTable=ipspAutostartIkeTable, ipspCredCredential=ipspCredCredential, ipspEspTranCipherKeyRounds=ipspEspTranCipherKeyRounds, ipspLoggingCompliance=ipspLoggingCompliance, ipspPeerIdFiltLastChanged=ipspPeerIdFiltLastChanged, ipspIkePropPrfAlgorithm=ipspIkePropPrfAlgorithm, ipspSaPreActESPAuthSecretName=ipspSaPreActESPAuthSecretName, ipspConformanceObjects=ipspConformanceObjects, ipspIpsoHeadFiltRowStatus=ipspIpsoHeadFiltRowStatus, ipspAhTranName=ipspAhTranName, ipspIPDestinationAddress=ipspIPDestinationAddress, ipspIpsecActGranularity=ipspIpsecActGranularity, ipspSaPreActLastChanged=ipspSaPreActLastChanged, ipspTimeFiltStorageType=ipspTimeFiltStorageType, ipspEspTranStorageType=ipspEspTranStorageType, ipspSaNegParamMinLifetimeKB=ipspSaNegParamMinLifetimeKB, ipspEspTranCipherTransformId=ipspEspTranCipherTransformId, ipspCredLastChanged=ipspCredLastChanged, ipspRejectIKEActionLog=ipspRejectIKEActionLog, IpspIPPacketLogging=IpspIPPacketLogging, ipspIkePropMaxLifetimeKB=ipspIkePropMaxLifetimeKB, ipspIpHeadFiltSrcAddressBegin=ipspIpHeadFiltSrcAddressBegin, ipspSubFiltPriority=ipspSubFiltPriority, ipspIcmsCredentialName=ipspIcmsCredentialName, ipspIpsecTranTransformName=ipspIpsecTranTransformName, ipspRuleDefAdminStatus=ipspRuleDefAdminStatus, ipspSaNegParamLastChanged=ipspSaNegParamLastChanged, ipspIkeActLastChanged=ipspIkeActLastChanged, ipspSaPreActAHSPI=ipspSaPreActAHSPI, ipspCompFiltDescription=ipspCompFiltDescription, ipspIpsecPropStorageType=ipspIpsecPropStorageType, ipspGroupContComponentType=ipspGroupContComponentType, ipspEspTranCipherKeyLength=ipspEspTranCipherKeyLength, ipspSaPreActESPTransformName=ipspSaPreActESPTransformName, ipspPacketPart=ipspPacketPart, ipspIpHeadFiltDstAddressBegin=ipspIpHeadFiltDstAddressBegin, ipspIpOffFiltOffset=ipspIpOffFiltOffset, ipspRctLastChanged=ipspRctLastChanged, ipspTimeFiltName=ipspTimeFiltName, IpspCredentialType=IpspCredentialType, ipspIkePhase1Filter=ipspIkePhase1Filter, ipspGroupContentsGroup=ipspGroupContentsGroup, ipspIcmsLastChanged=ipspIcmsLastChanged, ipspCompFiltName=ipspCompFiltName, ipspSubfiltersTable=ipspSubfiltersTable, ipspIkeActIdentityContext=ipspIkeActIdentityContext, ipspIpHeadFiltProtocol=ipspIpHeadFiltProtocol, ipspIpsecActPeerGatewayIdName=ipspIpsecActPeerGatewayIdName, ipspIpcompTranStorageType=ipspIpcompTranStorageType, ipspAutoIkePriority=ipspAutoIkePriority, ipspIpHeadFiltLastChanged=ipspIpHeadFiltLastChanged, ipspIpsecProposalsEntry=ipspIpsecProposalsEntry, ipspGroupContRowStatus=ipspGroupContRowStatus, ipspPeerIdRowStatus=ipspPeerIdRowStatus, ipspIpHeadFiltSrcHighPort=ipspIpHeadFiltSrcHighPort, ipspIkeIdStorageType=ipspIkeIdStorageType, ipspCredentialEntry=ipspCredentialEntry, ipspIpsecTransformsTable=ipspIpsecTransformsTable, ipspCompoundFilterGroup=ipspCompoundFilterGroup, ipspPeerIdFilterGroup=ipspPeerIdFilterGroup, ipspSaPreActStorageType=ipspSaPreActStorageType, ipspSaPreActActionDescription=ipspSaPreActActionDescription, ipspTimeFilterTable=ipspTimeFilterTable, ipspSaNegParamRowStatus=ipspSaNegParamRowStatus, ipspIpsecTransformsEntry=ipspIpsecTransformsEntry, ipspRejectIKEAction=ipspRejectIKEAction, ipspPeerIdName=ipspPeerIdName, ipspPeerIdPriority=ipspPeerIdPriority, ipspIkeActIdentityType=ipspIkeActIdentityType, ipspAutoIkeDestPort=ipspAutoIkeDestPort, ipspGroupContComponentName=ipspGroupContComponentName, ipspIpsecPropTransformsName=ipspIpsecPropTransformsName, ipspIpHeadFiltSrcAddressEnd=ipspIpHeadFiltSrcAddressEnd, ipspCompActRowStatus=ipspCompActRowStatus, ipspSaPreActActionLifetimeKB=ipspSaPreActActionLifetimeKB, ipspSubFiltSubfilter=ipspSubFiltSubfilter, ipspDropActionLog=ipspDropActionLog, ipspPacketDirection=ipspPacketDirection, ipspAhTranStorageType=ipspAhTranStorageType, ipspStaticFilters=ipspStaticFilters, ipspAhTranRowStatus=ipspAhTranRowStatus, ipspCredMngCRLEntry=ipspCredMngCRLEntry, ipspIkePropVendorId=ipspIkePropVendorId, ipspIpsecActUseIkeGroup=ipspIpsecActUseIkeGroup, ipspRuleDefRowStatus=ipspRuleDefRowStatus, ipspIpsecActRowStatus=ipspIpsecActRowStatus, ipspPeerIdFiltIdentityType=ipspPeerIdFiltIdentityType, ipspCredStorageType=ipspCredStorageType, ipspCompFiltStorageType=ipspCompFiltStorageType, ipspPeerIdFiltName=ipspPeerIdFiltName, ipspAhTransformEntry=ipspAhTransformEntry, ipspCredFiltLastChanged=ipspCredFiltLastChanged, ipspPeerIdCredentialName=ipspPeerIdCredentialName, ipspSubActSubActionName=ipspSubActSubActionName, ipspSaPreActActionLifetimeSec=ipspSaPreActActionLifetimeSec, ipspSubactionsEntry=ipspSubactionsEntry, ipspTrueFilterInstance=ipspTrueFilterInstance, ipspIpsecTranType=ipspIpsecTranType, ipspIpOffFiltRowStatus=ipspIpOffFiltRowStatus, ipspEndGroupRowStatus=ipspEndGroupRowStatus, ipspSubfiltersEntry=ipspSubfiltersEntry, ipspPacketNotification=ipspPacketNotification, ipspIPDestinationType=ipspIPDestinationType, aiipspCompActRowStatus=aiipspCompActRowStatus, ipspIpsecTranRowStatus=ipspIpsecTranRowStatus, ipspCredSegLastChanged=ipspCredSegLastChanged, ipspEndpointGroup=ipspEndpointGroup, ipspSaPreconfiguredActionTable=ipspSaPreconfiguredActionTable, ipspTimeFiltTimeOfDayMaskStart=ipspTimeFiltTimeOfDayMaskStart, ipspSaPreActActionName=ipspSaPreActActionName, ipspIpsecCredMngServiceEntry=ipspIpsecCredMngServiceEntry, ipspIcmsRowStatus=ipspIcmsRowStatus, ipspIpsecActName=ipspIpsecActName, ipspIPSourceType=ipspIPSourceType, ipspSubFiltLastChanged=ipspSubFiltLastChanged, ipspCredentialTable=ipspCredentialTable, ipspCompFiltLogicType=ipspCompFiltLogicType, ipspCredSize=ipspCredSize, ipspIkeActPropStorageType=ipspIkeActPropStorageType, ipspNotificationVariables=ipspNotificationVariables, ipspIpHeadFiltRowStatus=ipspIpHeadFiltRowStatus, ipspRevokedCertificateEntry=ipspRevokedCertificateEntry, ipspMIB=ipspMIB, ipspTimeFiltMonthOfYearMask=ipspTimeFiltMonthOfYearMask, ipspIkeActionProposalsEntry=ipspIkeActionProposalsEntry, ipspIpcompTranPrivateAlgorithm=ipspIpcompTranPrivateAlgorithm, ipspIkeActionTable=ipspIkeActionTable, ipspCredSegIndex=ipspCredSegIndex, ipspIpsecActDFHandling=ipspIpsecActDFHandling, ipspSaNegParamName=ipspSaNegParamName, ipspEspTranReplayWindowSize=ipspEspTranReplayWindowSize, ipspCredentialFilterTable=ipspCredentialFilterTable, ipspIpsoHeadFiltType=ipspIpsoHeadFiltType, ipspIpsecActUsePfs=ipspIpsecActUsePfs, ipspIpsecPropName=ipspIpsecPropName, ipspIpsecPropLastChanged=ipspIpsecPropLastChanged, ipspPeerIdFiltRowStatus=ipspPeerIdFiltRowStatus, ipspIpsecCredMngServiceTable=ipspIpsecCredMngServiceTable, ipspEspTranMaxLifetimeKB=ipspEspTranMaxLifetimeKB, ipspAhTranReplayWindowSize=ipspAhTranReplayWindowSize, ipspSaNegParamMinLifetimeSecs=ipspSaNegParamMinLifetimeSecs, ipspPeerIdType=ipspPeerIdType, ipspIpsecActDoPacketLogging=ipspIpsecActDoPacketLogging, ipspIkePropProposalRowStatus=ipspIkePropProposalRowStatus, aiipspCompActStorageType=aiipspCompActStorageType, ipspIkeActDoPacketLogging=ipspIkeActDoPacketLogging, ipspIpsoHeadFiltClassification=ipspIpsoHeadFiltClassification, ipspIkeIdCredentialName=ipspIkeIdCredentialName, ipspAcceptAction=ipspAcceptAction, ipspSaPreActDoActionLogging=ipspSaPreActDoActionLogging, ipspSaPreActDoPacketLogging=ipspSaPreActDoPacketLogging, ipspIkeIdLastChanged=ipspIkeIdLastChanged, ipspIpOffFiltName=ipspIpOffFiltName, ipspIpsecPropRowStatus=ipspIpsecPropRowStatus, ipspAutoIkeLastChanged=ipspAutoIkeLastChanged, ipspIpcompTranLastChanged=ipspIpcompTranLastChanged, ipspCredType=ipspCredType, ipspIkeActExchangeMode=ipspIkeActExchangeMode, ipspSaNegotiationParametersTable=ipspSaNegotiationParametersTable, ipspEspTransformTable=ipspEspTransformTable, ipspStaticActionGroup=ipspStaticActionGroup, ipspIpsecActVendorId=ipspIpsecActVendorId, IpspAdminStatus=IpspAdminStatus, ipspSaNegParamIdleDurationSecs=ipspSaNegParamIdleDurationSecs, ipspCredMngName=ipspCredMngName, ipspActionNotificationGroup=ipspActionNotificationGroup, ipspTrueFilter=ipspTrueFilter, ipspIpsecTranStorageType=ipspIpsecTranStorageType, ipspIcmsName=ipspIcmsName, ipspIPsecCompliance=ipspIPsecCompliance, ipspIpsecActGroupId=ipspIpsecActGroupId, ipspEspTranIntegrityAlgorithmId=ipspEspTranIntegrityAlgorithmId, ipspEspTranRowStatus=ipspEspTranRowStatus, ipspAhTransformTable=ipspAhTransformTable, ipspNotifications=ipspNotifications, ipspEndGroupIdentType=ipspEndGroupIdentType, ipspIpHeadFiltDstLowPort=ipspIpHeadFiltDstLowPort, ipspSaPreconfiguredActionEntry=ipspSaPreconfiguredActionEntry, ipspRuleDefinitionGroup=ipspRuleDefinitionGroup, ipspEndGroupName=ipspEndGroupName, ipspRctCertSerialNumber=ipspRctCertSerialNumber)
mibBuilder.exportSymbols("IPSEC-POLICY-MIB", ipspIpsecGroup=ipspIpsecGroup, ipspIpOffFiltStorageType=ipspIpOffFiltStorageType, ipspIpsoHeaderFilterEntry=ipspIpsoHeaderFilterEntry, ipspIkeActPropRowStatus=ipspIkeActPropRowStatus, ipspSaPreActPeerGatewayIdName=ipspSaPreActPeerGatewayIdName, ipspRuleFilterCompliance=ipspRuleFilterCompliance, ipspStaticActions=ipspStaticActions, ipspIpsoHeaderFilterTable=ipspIpsoHeaderFilterTable, ipspCompoundFilterTable=ipspCompoundFilterTable, ipspIpsoHeadFiltLastChanged=ipspIpsoHeadFiltLastChanged, ipspIpHeadFiltType=ipspIpHeadFiltType, ipspRuleDefAction=ipspRuleDefAction, ipspIcmsStorageType=ipspIcmsStorageType, ipspIkePropAuthenticationMethod=ipspIkePropAuthenticationMethod, ipspIpsecTranPriority=ipspIpsecTranPriority, ipspIpOffFiltNumber=ipspIpOffFiltNumber, ipspCompFiltLastChanged=ipspCompFiltLastChanged, ipspTimeFiltRowStatus=ipspTimeFiltRowStatus, ipspIpcompTranMaxLifetimeSec=ipspIpcompTranMaxLifetimeSec, ipspActionNotification=ipspActionNotification, ipspIpsecPropProtocolId=ipspIpsecPropProtocolId, ipspAhTranMaxLifetimeKB=ipspAhTranMaxLifetimeKB, ipspIpHeaderFilterTable=ipspIpHeaderFilterTable, ipspIPSourceAddress=ipspIPSourceAddress, ipspCredFiltRowStatus=ipspCredFiltRowStatus, ipspCompoundActionGroup=ipspCompoundActionGroup, ipspRctStorageType=ipspRctStorageType, ipspSaNegParamRefreshThresholdKB=ipspSaNegParamRefreshThresholdKB, ipspCmcCRLName=ipspCmcCRLName, ipspIpsecActionEntry=ipspIpsecActionEntry, ipspIkeActionProposalsTable=ipspIkeActionProposalsTable, ipspIkeGroup=ipspIkeGroup, ipspCredFiltStorageType=ipspCredFiltStorageType, ipspSaNegotiationParametersEntry=ipspSaNegotiationParametersEntry, ipspIkePropProposalLastChanged=ipspIkePropProposalLastChanged, ipspIpHeadFiltIPv6FlowLabel=ipspIpHeadFiltIPv6FlowLabel, ipspPeerIdLastChanged=ipspPeerIdLastChanged, ipspSaPreActESPEncSecretName=ipspSaPreActESPEncSecretName, ipspPreconfiguredGroup=ipspPreconfiguredGroup, ipspCompActStorageType=ipspCompActStorageType, ipspIkeActRowStatus=ipspIkeActRowStatus, ipspLocalConfigObjects=ipspLocalConfigObjects, ipspIPInterfaceType=ipspIPInterfaceType, ipspSubFiltStorageType=ipspSubFiltStorageType, ipspCredFiltMatchFieldName=ipspCredFiltMatchFieldName, ipspCmcThisUpdate=ipspCmcThisUpdate, ipspAutoIkeDestAddress=ipspAutoIkeDestAddress, ipspIkeProposalEntry=ipspIkeProposalEntry, ipspTimeFiltDayOfWeekMask=ipspTimeFiltDayOfWeekMask, ipspGroupContFilter=ipspGroupContFilter, ipspIkePropLifetimeDerivedKeys=ipspIkePropLifetimeDerivedKeys, ipspIpsecPropPriority=ipspIpsecPropPriority, ipspIpsoHeadFiltName=ipspIpsoHeadFiltName, ipspCredentialSegmentEntry=ipspCredentialSegmentEntry, ipspIpsoHeadFiltProtectionAuth=ipspIpsoHeadFiltProtectionAuth, ipspPeerIdValue=ipspPeerIdValue, ipspSaPreActRowStatus=ipspSaPreActRowStatus, ipspGroupContStorageType=ipspGroupContStorageType, ipspIkePropHashAlgorithm=ipspIkePropHashAlgorithm, ipspSubFiltRowStatus=ipspSubFiltRowStatus, ipspIpcompTranDictionarySize=ipspIpcompTranDictionarySize, ipspCredRemoteID=ipspCredRemoteID, ipspIpcompTransformTable=ipspIpcompTransformTable, ipspIkeActThresholdDerivedKeys=ipspIkeActThresholdDerivedKeys, ipspActionExecuted=ipspActionExecuted, ipspStaticFilterGroup=ipspStaticFilterGroup, ipspIkePropCipherKeyLength=ipspIkePropCipherKeyLength, IpspIdentityFilter=IpspIdentityFilter, ipspEndpointToGroupTable=ipspEndpointToGroupTable, ipspDropAction=ipspDropAction, ipspSubFiltSubfilterIsNegated=ipspSubFiltSubfilterIsNegated, ipspTimeFiltTimeOfDayMaskEnd=ipspTimeFiltTimeOfDayMaskEnd, ipspSaPreActSADirection=ipspSaPreActSADirection, ipspSystemPolicyGroupName=ipspSystemPolicyGroupName, ipspIpHeaderFilterEntry=ipspIpHeaderFilterEntry, ipspIpsecActDoActionLogging=ipspIpsecActDoActionLogging, ipspPeerIdentityEntry=ipspPeerIdentityEntry, ipspIcmsPolicyStatement=ipspIcmsPolicyStatement, ipspIpcompTranMaxLifetimeKB=ipspIpcompTranMaxLifetimeKB, ipspRctRowStatus=ipspRctRowStatus, ipspIPOffsetFilterGroup=ipspIPOffsetFilterGroup, ipspIkeIdentityEntry=ipspIkeIdentityEntry, ipspRuleDefStorageType=ipspRuleDefStorageType, ipspIpHeadFiltName=ipspIpHeadFiltName, ipspEspTranLastChanged=ipspEspTranLastChanged, ipspIcmsDistinguishedName=ipspIcmsDistinguishedName, ipspCredSegValue=ipspCredSegValue, ipspRuleDefinitionTable=ipspRuleDefinitionTable, ipspSubactionsTable=ipspSubactionsTable, ipspIpHeadFiltStorageType=ipspIpHeadFiltStorageType, ipspTimeFiltPeriodStart=ipspTimeFiltPeriodStart, ipspEndpointToGroupEntry=ipspEndpointToGroupEntry, ipspIpsecActLastChanged=ipspIpsecActLastChanged, ipspCredentialSegmentTable=ipspCredentialSegmentTable, ipspGroupContName=ipspGroupContName, ipspIcmsMaxChainLength=ipspIcmsMaxChainLength, ipspIpsecSystemPolicyNameGroup=ipspIpsecSystemPolicyNameGroup, ipspPeerIdentityTable=ipspPeerIdentityTable, ipspIpsecActParametersName=ipspIpsecActParametersName, ipspRuleDefName=ipspRuleDefName, ipspCredMngCRLTable=ipspCredMngCRLTable, ipspIpOffsetFilterTable=ipspIpOffsetFilterTable, ipspCmcDistributionPoint=ipspCmcDistributionPoint, ipspIpOffFiltType=ipspIpOffFiltType, ipspCredRowStatus=ipspCredRowStatus, ipspIkeActParametersName=ipspIkeActParametersName, ipspRuleDefinitionEntry=ipspRuleDefinitionEntry, ipspCompoundActionTable=ipspCompoundActionTable, ipspCredName=ipspCredName, ipspTimeFiltDayOfMonthMask=ipspTimeFiltDayOfMonthMask, ipspRctRevokedReason=ipspRctRevokedReason, ipspIpsecActMode=ipspIpsecActMode, ipspIpsoHeadFiltStorageType=ipspIpsoHeadFiltStorageType, ipspTimeFilterGroup=ipspTimeFilterGroup, ipspIpsecActStorageType=ipspIpsecActStorageType, ipspCredAdminStatus=ipspCredAdminStatus, ipspSaPreActIPCompTransformName=ipspSaPreActIPCompTransformName, ipspIpHeadFiltDstHighPort=ipspIpHeadFiltDstHighPort, ipspIPInterfaceAddress=ipspIPInterfaceAddress, ipspCredFiltName=ipspCredFiltName, ipspIkePropCipherAlgorithm=ipspIkePropCipherAlgorithm, ipspIkePropCipherKeyRounds=ipspIkePropCipherKeyRounds, ipspAhTranLastChanged=ipspAhTranLastChanged, ipspAutoIkeAddressType=ipspAutoIkeAddressType, ipspEspTranName=ipspEspTranName, ipspIpcompTranName=ipspIpcompTranName, ipspCredSegStorageType=ipspCredSegStorageType, ipspCompActLastChanged=ipspCompActLastChanged, ipspAutoIkeSourceAddress=ipspAutoIkeSourceAddress, ipspCredentialFilterGroup=ipspCredentialFilterGroup, ipspIpsecProposalsTable=ipspIpsecProposalsTable, ipspPeerIdAddress=ipspPeerIdAddress, ipspIkePropMaxLifetimeSecs=ipspIkePropMaxLifetimeSecs, ipspCompoundFilterEntry=ipspCompoundFilterEntry, ipspAutoIkeProtocol=ipspAutoIkeProtocol, ipspPeerIdentityFilterTable=ipspPeerIdentityFilterTable, ipspCmcLastChanged=ipspCmcLastChanged, ipspIkeActVendorId=ipspIkeActVendorId, ipspIpOffFiltValue=ipspIpOffFiltValue, ipspAhTranAlgorithm=ipspAhTranAlgorithm, ipspGroupContPriority=ipspGroupContPriority, ipspIkeActAgressiveModeGroupId=ipspIkeActAgressiveModeGroupId, ipspRctRevokedDate=ipspRctRevokedDate, ipspAutoIkeRowStatus=ipspAutoIkeRowStatus, ipspRuleDefDescription=ipspRuleDefDescription, ipspCmcRowStatus=ipspCmcRowStatus, ipspIKECompliance=ipspIKECompliance, ipspIkeActPeerName=ipspIkeActPeerName, ipspIpsecActProposalsName=ipspIpsecActProposalsName, ipspSaPreActActionType=ipspSaPreActActionType, ipspIpcompTranAlgorithm=ipspIpcompTranAlgorithm, ipspAhTranReplayProtection=ipspAhTranReplayProtection, ipspIPHeaderFilterGroup=ipspIPHeaderFilterGroup, ipspEndGroupLastChanged=ipspEndGroupLastChanged, ipspIkeActPropName=ipspIkeActPropName, ipspIkePropProposalStorageType=ipspIkePropProposalStorageType, ipspIpcompTransformEntry=ipspIpcompTransformEntry, ipspEspTransformEntry=ipspEspTransformEntry, ipspIpHeadFiltIPVersion=ipspIpHeadFiltIPVersion)
